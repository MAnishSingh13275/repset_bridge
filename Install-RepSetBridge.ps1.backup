# ================================================================
# RepSet Bridge - Automated Installation Script Foundation
# Secure, validated installation with comprehensive error handling
# ================================================================

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$PairCode,
    
    [Parameter(Mandatory=$true)]
    [string]$Signature,
    
    [Parameter(Mandatory=$true)]
    [string]$Nonce,
    
    [Parameter(Mandatory=$true)]
    [string]$GymId,
    
    [Parameter(Mandatory=$true)]
    [string]$ExpiresAt,
    
    [Parameter(Mandatory=$false)]
    [string]$PlatformEndpoint = "https://app.repset.com",
    
    [Parameter(Mandatory=$false)]
    [string]$InstallPath = "$env:ProgramFiles\RepSet\Bridge",
    
    [Parameter(Mandatory=$false)]
    [switch]$Force,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipPrerequisites
)

# ================================================================
# Global Variables and Constants
# ================================================================

$script:LogFile = "$env:TEMP\RepSetBridge-Install-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
$script:ServiceName = "RepSetBridge"
$script:ServiceDisplayName = "RepSet Bridge Service"
$script:ServiceDescription = "RepSet Bridge - Gym Equipment Integration Service"
$script:GitHubRepo = "repset/repset_bridge"
$script:ConfigFileName = "config.yaml"
$script:InstallationId = [System.Guid]::NewGuid().ToString()
$script:InstallationStartTime = Get-Date

# Error codes for different failure scenarios
$script:ErrorCodes = @{
    Success = 0
    InvalidSignature = 1
    ExpiredCommand = 2
    InsufficientPrivileges = 3
    SystemRequirementsNotMet = 4
    DownloadFailed = 5
    IntegrityVerificationFailed = 6
    InstallationFailed = 7
    ServiceInstallationFailed = 8
    ConfigurationFailed = 9
    ConnectionTestFailed = 10
    RollbackFailed = 11
}

# ================================================================
# Logging and Output Functions
# ================================================================

function Write-InstallationLog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Debug', 'Progress')]
        [string]$Level,
        
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$Context = @{},
        
        [Parameter(Mandatory=$false)]
        [switch]$NoConsole,
        
        [Parameter(Mandatory=$false)]
        [string]$Step = "",
        
        [Parameter(Mandatory=$false)]
        [int]$StepNumber = 0,
        
        [Parameter(Mandatory=$false)]
        [int]$TotalSteps = 0
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $contextStr = if ($Context.Count -gt 0) { " | Context: $($Context | ConvertTo-Json -Compress)" } else { "" }
    $stepStr = if ($Step) { " | Step: $Step" } else { "" }
    $logEntry = "[$timestamp] [$Level] $Message$stepStr$contextStr"
    
    # Enhanced context for structured logging
    $logContext = @{
        Timestamp = $timestamp
        Level = $Level
        Message = $Message
        InstallationId = $script:InstallationId
        Step = $Step
        StepNumber = $StepNumber
        TotalSteps = $TotalSteps
        Context = $Context
    }
    
    # Write to multiple log targets
    Write-LogToFile -LogEntry $logEntry -Context $logContext
    Write-LogToConsole -Level $Level -Message $Message -NoConsole $NoConsole
    Write-LogToEventLog -Level $Level -Message $Message -Context $logContext
    Send-LogToPlatform -Level $Level -Message $Message -Context $logContext
}

function Write-LogToFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$LogEntry,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$Context = @{}
    )
    
    try {
        # Write to main log file
        Add-Content -Path $script:LogFile -Value $LogEntry -ErrorAction SilentlyContinue
        
        # Write structured log entry for machine processing
        $structuredLogFile = $script:LogFile -replace '\.log$', '.json'
        $jsonEntry = $Context | ConvertTo-Json -Compress
        Add-Content -Path $structuredLogFile -Value $jsonEntry -ErrorAction SilentlyContinue
        
        # Rotate log files if they get too large (>10MB)
        $logFileInfo = Get-Item -Path $script:LogFile -ErrorAction SilentlyContinue
        if ($logFileInfo -and $logFileInfo.Length -gt 10MB) {
            $rotatedLogFile = $script:LogFile -replace '\.log$', "-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
            Move-Item -Path $script:LogFile -Destination $rotatedLogFile -ErrorAction SilentlyContinue
        }
    }
    catch {
        # If we can't write to log file, continue silently
    }
}

function Write-LogToConsole {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Level,
        
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [switch]$NoConsole
    )
    
    # Write to console unless suppressed
    if (-not $NoConsole) {
        $timestamp = Get-Date -Format "HH:mm:ss"
        $prefix = "[$timestamp]"
        
        switch ($Level) {
            'Info'     { Write-Host "$prefix $Message" -ForegroundColor White }
            'Success'  { Write-Host "$prefix ✓ $Message" -ForegroundColor Green }
            'Warning'  { Write-Host "$prefix ⚠ $Message" -ForegroundColor Yellow }
            'Error'    { Write-Host "$prefix ✗ $Message" -ForegroundColor Red }
            'Progress' { Write-Host "$prefix → $Message" -ForegroundColor Cyan }
            'Debug'    { if ($VerbosePreference -eq 'Continue') { Write-Host "$prefix [DEBUG] $Message" -ForegroundColor Gray } }
        }
    }
}

function Write-LogToEventLog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Level,
        
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$Context = @{}
    )
    
    # Write to Windows Event Log for important events
    if ($Level -in @('Error', 'Warning', 'Success')) {
        try {
            $eventSource = "RepSetBridge-Installer"
            
            # Create event source if it doesn't exist
            if (-not [System.Diagnostics.EventLog]::SourceExists($eventSource)) {
                try {
                    [System.Diagnostics.EventLog]::CreateEventSource($eventSource, "Application")
                    Start-Sleep -Seconds 1  # Allow time for source creation
                }
                catch {
                    # If we can't create the source, skip event logging
                    return
                }
            }
            
            # Determine event type and ID
            $eventType = switch ($Level) {
                'Error'   { 'Error'; $eventId = 1001 }
                'Warning' { 'Warning'; $eventId = 1002 }
                'Success' { 'Information'; $eventId = 1003 }
                default   { 'Information'; $eventId = 1000 }
            }
            
            # Create detailed event message
            $eventMessage = @"
RepSet Bridge Installation Event

Message: $Message
Installation ID: $($script:InstallationId)
Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Level: $Level

$(if ($Context.Count -gt 0) { "Context: $($Context | ConvertTo-Json -Depth 3)" })
"@
            
            Write-EventLog -LogName Application -Source $eventSource -EntryType $eventType -EventId $eventId -Message $eventMessage
        }
        catch {
            # If we can't write to event log, continue silently
        }
    }
}

function Send-LogToPlatform {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Level,
        
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$Context = @{}
    )
    
    # Send real-time progress to platform (if connection available)
    try {
        # Only send important events to avoid overwhelming the platform
        if ($Level -in @('Error', 'Warning', 'Success', 'Progress')) {
            $logData = @{
                installationId = $script:InstallationId
                gymId = $GymId
                timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
                level = $Level.ToLower()
                message = $Message
                step = $Context.Step
                stepNumber = $Context.StepNumber
                totalSteps = $Context.TotalSteps
                context = $Context
            }
            
            # Send to platform endpoint (non-blocking)
            $platformUrl = "$PlatformEndpoint/api/installation/logs"
            $headers = @{
                'Content-Type' = 'application/json'
                'User-Agent' = 'RepSet-Bridge-Installer/1.0'
            }
            
            # Use background job to avoid blocking installation
            Start-Job -ScriptBlock {
                param($Url, $Headers, $Data)
                try {
                    $json = $Data | ConvertTo-Json -Depth 3
                    Invoke-RestMethod -Uri $Url -Method Post -Headers $Headers -Body $json -TimeoutSec 5 -ErrorAction SilentlyContinue
                }
                catch {
                    # Silently ignore platform logging failures
                }
            } -ArgumentList $platformUrl, $headers, $logData | Out-Null
        }
    }
    catch {
        # If platform logging fails, continue silently
    }
}

function Send-InstallationNotification {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateSet('Started', 'Progress', 'Success', 'Failed')]
        [string]$Status,
        
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$Details = @{},
        
        [Parameter(Mandatory=$false)]
        [string]$ErrorCode = ""
    )
    
    Write-InstallationLog -Level Debug -Message "Sending installation notification: $Status"
    
    try {
        $notificationData = @{
            installationId = $script:InstallationId
            gymId = $GymId
            status = $Status.ToLower()
            message = $Message
            timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
            details = $Details
            errorCode = $ErrorCode
            systemInfo = @{
                os = "$([System.Environment]::OSVersion.VersionString)"
                powershellVersion = "$($PSVersionTable.PSVersion)"
                architecture = "$([System.Environment]::ProcessorArchitecture)"
                machineName = "$([System.Environment]::MachineName)"
            }
        }
        
        $platformUrl = "$PlatformEndpoint/api/installation/notifications"
        $headers = @{
            'Content-Type' = 'application/json'
            'User-Agent' = 'RepSet-Bridge-Installer/1.0'
        }
        
        $json = $notificationData | ConvertTo-Json -Depth 4
        
        # Send notification with retry logic
        $maxRetries = 3
        $retryDelay = 2
        
        for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
            try {
                $response = Invoke-RestMethod -Uri $platformUrl -Method Post -Headers $headers -Body $json -TimeoutSec 10 -ErrorAction Stop
                Write-InstallationLog -Level Debug -Message "Installation notification sent successfully (attempt $attempt)"
                return $true
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Failed to send notification (attempt $attempt): $($_.Exception.Message)"
                if ($attempt -lt $maxRetries) {
                    Start-Sleep -Seconds ($retryDelay * $attempt)
                }
            }
        }
        
        Write-InstallationLog -Level Warning -Message "Failed to send installation notification after $maxRetries attempts"
        return $false
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error sending installation notification: $($_.Exception.Message)"
        return $false
    }
}

function Write-Progress-Step {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Step,
        
        [Parameter(Mandatory=$true)]
        [int]$StepNumber,
        
        [Parameter(Mandatory=$true)]
        [int]$TotalSteps,
        
        [Parameter(Mandatory=$false)]
        [string]$Status = "In Progress",
        
        [Parameter(Mandatory=$false)]
        [string]$SubStep = "",
        
        [Parameter(Mandatory=$false)]
        [int]$SubStepNumber = 0,
        
        [Parameter(Mandatory=$false)]
        [int]$TotalSubSteps = 0
    )
    
    $percentComplete = [math]::Round(($StepNumber / $TotalSteps) * 100)
    
    # Calculate sub-step progress if provided
    if ($TotalSubSteps -gt 0 -and $SubStepNumber -gt 0) {
        $subStepPercent = ($SubStepNumber / $TotalSubSteps) * (100 / $TotalSteps)
        $stepBasePercent = (($StepNumber - 1) / $TotalSteps) * 100
        $percentComplete = [math]::Round($stepBasePercent + $subStepPercent)
        
        $progressStatus = "$Step - $Status"
        if ($SubStep) {
            $progressStatus += " ($SubStep - $SubStepNumber/$TotalSubSteps)"
        }
    }
    else {
        $progressStatus = "$Step - $Status"
    }
    
    # Update PowerShell progress bar
    Write-Progress -Activity "RepSet Bridge Installation" -Status $progressStatus -PercentComplete $percentComplete
    
    # Create detailed progress context
    $progressContext = @{
        Step = $Step
        StepNumber = $StepNumber
        TotalSteps = $TotalSteps
        Status = $Status
        PercentComplete = $percentComplete
    }
    
    if ($SubStep) {
        $progressContext.SubStep = $SubStep
        $progressContext.SubStepNumber = $SubStepNumber
        $progressContext.TotalSubSteps = $TotalSubSteps
    }
    
    # Log progress with enhanced context
    $progressMessage = "Step $StepNumber/$TotalSteps`: $Step - $Status"
    if ($SubStep) {
        $progressMessage += " ($SubStep - $SubStepNumber/$TotalSubSteps)"
    }
    
    Write-InstallationLog -Level Progress -Message $progressMessage -Context $progressContext -Step $Step -StepNumber $StepNumber -TotalSteps $TotalSteps
    
    # Send real-time progress to platform
    Send-ProgressToPlatform -Step $Step -StepNumber $StepNumber -TotalSteps $TotalSteps -Status $Status -PercentComplete $percentComplete -SubStep $SubStep -SubStepNumber $SubStepNumber -TotalSubSteps $TotalSubSteps
}

function Send-ProgressToPlatform {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Step,
        
        [Parameter(Mandatory=$true)]
        [int]$StepNumber,
        
        [Parameter(Mandatory=$true)]
        [int]$TotalSteps,
        
        [Parameter(Mandatory=$true)]
        [string]$Status,
        
        [Parameter(Mandatory=$true)]
        [int]$PercentComplete,
        
        [Parameter(Mandatory=$false)]
        [string]$SubStep = "",
        
        [Parameter(Mandatory=$false)]
        [int]$SubStepNumber = 0,
        
        [Parameter(Mandatory=$false)]
        [int]$TotalSubSteps = 0
    )
    
    try {
        $progressData = @{
            installationId = $script:InstallationId
            gymId = $GymId
            timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
            step = $Step
            stepNumber = $StepNumber
            totalSteps = $TotalSteps
            status = $Status
            percentComplete = $PercentComplete
        }
        
        if ($SubStep) {
            $progressData.subStep = $SubStep
            $progressData.subStepNumber = $SubStepNumber
            $progressData.totalSubSteps = $TotalSubSteps
        }
        
        $platformUrl = "$PlatformEndpoint/api/installation/progress"
        $headers = @{
            'Content-Type' = 'application/json'
            'User-Agent' = 'RepSet-Bridge-Installer/1.0'
        }
        
        $json = $progressData | ConvertTo-Json -Depth 3
        
        # Send progress update asynchronously to avoid blocking installation
        Start-Job -ScriptBlock {
            param($Url, $Headers, $Data)
            try {
                Invoke-RestMethod -Uri $Url -Method Post -Headers $Headers -Body $Data -TimeoutSec 5 -ErrorAction SilentlyContinue
            }
            catch {
                # Silently ignore platform progress update failures
            }
        } -ArgumentList $platformUrl, $headers, $json | Out-Null
    }
    catch {
        # If platform progress update fails, continue silently
    }
}

function Write-InstallationSummary {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [bool]$Success,
        
        [Parameter(Mandatory=$false)]
        [string]$ErrorMessage = "",
        
        [Parameter(Mandatory=$false)]
        [int]$ErrorCode = 0,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$InstallationDetails = @{}
    )
    
    Write-InstallationLog -Level Info -Message "=== INSTALLATION SUMMARY ==="
    Write-InstallationLog -Level Info -Message "Installation ID: $script:InstallationId"
    Write-InstallationLog -Level Info -Message "Gym ID: $GymId"
    Write-InstallationLog -Level Info -Message "Start Time: $($script:InstallationStartTime)"
    Write-InstallationLog -Level Info -Message "End Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    
    if ($script:InstallationStartTime) {
        $duration = (Get-Date) - $script:InstallationStartTime
        Write-InstallationLog -Level Info -Message "Duration: $([math]::Round($duration.TotalMinutes, 2)) minutes"
    }
    
    if ($Success) {
        Write-InstallationLog -Level Success -Message "Status: INSTALLATION SUCCESSFUL"
        Write-InstallationLog -Level Info -Message "Service Name: $script:ServiceName"
        Write-InstallationLog -Level Info -Message "Installation Path: $InstallPath"
        Write-InstallationLog -Level Info -Message "Configuration File: $(Join-Path $InstallPath "config\$script:ConfigFileName")"
        Write-InstallationLog -Level Info -Message "Log File: $script:LogFile"
        
        # Send success notification
        Send-InstallationNotification -Status Success -Message "RepSet Bridge installed successfully" -Details $InstallationDetails
        
        Write-InstallationLog -Level Info -Message ""
        Write-InstallationLog -Level Success -Message "🎉 RepSet Bridge has been successfully installed and started!"
        Write-InstallationLog -Level Info -Message "The bridge service is now running and will automatically start with Windows."
        Write-InstallationLog -Level Info -Message "You can monitor the service status in Windows Services (services.msc)."
        Write-InstallationLog -Level Info -Message ""
        Write-InstallationLog -Level Info -Message "Next steps:"
        Write-InstallationLog -Level Info -Message "1. Verify the bridge appears as 'Connected' in your RepSet platform"
        Write-InstallationLog -Level Info -Message "2. Test equipment connectivity through the platform"
        Write-InstallationLog -Level Info -Message "3. Review logs at: $(Join-Path $InstallPath "logs")"
    }
    else {
        Write-InstallationLog -Level Error -Message "Status: INSTALLATION FAILED"
        if ($ErrorMessage) {
            Write-InstallationLog -Level Error -Message "Error: $ErrorMessage"
        }
        if ($ErrorCode -gt 0) {
            Write-InstallationLog -Level Error -Message "Error Code: $ErrorCode"
        }
        
        # Send failure notification
        Send-InstallationNotification -Status Failed -Message $ErrorMessage -ErrorCode $ErrorCode.ToString() -Details $InstallationDetails
        
        Write-InstallationLog -Level Info -Message ""
        Write-InstallationLog -Level Error -Message "❌ RepSet Bridge installation failed."
        Write-InstallationLog -Level Info -Message "Please review the error details above and try again."
        Write-InstallationLog -Level Info -Message "For support, please provide the installation log: $script:LogFile"
        Write-InstallationLog -Level Info -Message ""
        Write-InstallationLog -Level Info -Message "Common solutions:"
        Write-InstallationLog -Level Info -Message "1. Ensure you're running PowerShell as Administrator"
        Write-InstallationLog -Level Info -Message "2. Check your internet connection"
        Write-InstallationLog -Level Info -Message "3. Verify Windows Defender isn't blocking the installation"
        Write-InstallationLog -Level Info -Message "4. Generate a new installation command if this one has expired"
    }
    
    Write-InstallationLog -Level Info -Message "=== END INSTALLATION SUMMARY ==="
}

# ================================================================
# Security and Validation Functions
# ================================================================

function Test-CommandSignature {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PairCode,
        
        [Parameter(Mandatory=$true)]
        [string]$Signature,
        
        [Parameter(Mandatory=$true)]
        [string]$Nonce,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId,
        
        [Parameter(Mandatory=$true)]
        [string]$ExpiresAt
    )
    
    Write-InstallationLog -Level Debug -Message "Validating command signature and parameters"
    
    try {
        # Validate expiration
        $expirationDate = [DateTime]::Parse($ExpiresAt)
        if ((Get-Date) -gt $expirationDate) {
            Write-InstallationLog -Level Error -Message "Installation command has expired. Please generate a new command from the platform."
            return $false
        }
        
        # Create the message that should have been signed
        $message = "$PairCode|$Nonce|$GymId|$ExpiresAt"
        
        # Note: In a real implementation, we would validate the HMAC signature here
        # For now, we'll do basic parameter validation
        if ([string]::IsNullOrWhiteSpace($PairCode) -or 
            [string]::IsNullOrWhiteSpace($Signature) -or 
            [string]::IsNullOrWhiteSpace($Nonce) -or 
            [string]::IsNullOrWhiteSpace($GymId)) {
            Write-InstallationLog -Level Error -Message "Invalid or missing required parameters"
            return $false
        }
        
        # Validate parameter formats
        if ($PairCode.Length -lt 8) {
            Write-InstallationLog -Level Error -Message "Invalid pair code format"
            return $false
        }
        
        if ($GymId -notmatch '^[a-zA-Z0-9\-_]+$') {
            Write-InstallationLog -Level Error -Message "Invalid gym ID format"
            return $false
        }
        
        Write-InstallationLog -Level Success -Message "Command signature and parameters validated successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error validating command signature: $($_.Exception.Message)"
        return $false
    }
}

function Test-CommandExpiration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ExpiresAt
    )
    
    try {
        $expirationDate = [DateTime]::Parse($ExpiresAt)
        $currentDate = Get-Date
        
        if ($currentDate -gt $expirationDate) {
            $expiredMinutes = [math]::Round(($currentDate - $expirationDate).TotalMinutes, 2)
            Write-InstallationLog -Level Error -Message "Installation command expired $expiredMinutes minutes ago. Please generate a new command."
            return $false
        }
        
        $remainingMinutes = [math]::Round(($expirationDate - $currentDate).TotalMinutes, 2)
        Write-InstallationLog -Level Info -Message "Command valid for $remainingMinutes more minutes"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error parsing expiration date: $($_.Exception.Message)"
        return $false
    }
}

# ================================================================
# System Requirements Validation Functions
# ================================================================

function Test-SystemRequirements {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Validating system requirements..."
    
    $requirements = @{
        AdminRights = $false
        PowerShellVersion = $false
        PowerShellExecutionPolicy = $false
        DotNetRuntime = $false
        WindowsVersion = $false
        WindowsFeatures = $false
        DiskSpace = $false
        NetworkAccess = $false
        MemoryAvailable = $false
    }
    
    $requirementDetails = @{}
    
    try {
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking administrator privileges" -SubStepNumber 1 -TotalSubSteps 9
        
        # Check if running as administrator
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        $requirements.AdminRights = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        
        if ($requirements.AdminRights) {
            Write-InstallationLog -Level Success -Message "✓ Running with Administrator privileges"
            $requirementDetails.AdminRights = "Administrator privileges confirmed"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Administrator privileges required"
            Write-InstallationLog -Level Error -Message "SOLUTION: Right-click PowerShell and select 'Run as Administrator', then run this command again."
            $requirementDetails.AdminRights = "Missing administrator privileges"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking PowerShell version" -SubStepNumber 2 -TotalSubSteps 9
        
        # Check PowerShell version (minimum 5.1)
        $psVersion = $PSVersionTable.PSVersion
        $requirements.PowerShellVersion = $psVersion.Major -ge 5 -and ($psVersion.Major -gt 5 -or $psVersion.Minor -ge 1)
        
        if ($requirements.PowerShellVersion) {
            Write-InstallationLog -Level Success -Message "✓ PowerShell version $($psVersion.ToString()) meets requirements (5.1+)"
            $requirementDetails.PowerShellVersion = "PowerShell $($psVersion.ToString())"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ PowerShell 5.1 or higher required. Current: $($psVersion.ToString())"
            Write-InstallationLog -Level Error -Message "SOLUTION: Install Windows Management Framework 5.1 or upgrade to PowerShell 7+"
            $requirementDetails.PowerShellVersion = "PowerShell $($psVersion.ToString()) - Upgrade required"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking execution policy" -SubStepNumber 3 -TotalSubSteps 9
        
        # Check PowerShell execution policy
        $requirements.PowerShellExecutionPolicy = Test-PowerShellExecutionPolicy
        if ($requirements.PowerShellExecutionPolicy) {
            Write-InstallationLog -Level Success -Message "✓ PowerShell execution policy allows script execution"
            $requirementDetails.PowerShellExecutionPolicy = "Execution policy allows scripts"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ PowerShell execution policy may restrict script execution"
            Write-InstallationLog -Level Info -Message "SOLUTION: Run 'Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser' if installation fails"
            $requirementDetails.PowerShellExecutionPolicy = "Execution policy may need adjustment"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking Windows version" -SubStepNumber 4 -TotalSubSteps 9
        
        # Check Windows version (minimum Windows 10 / Server 2016)
        $osVersion = [System.Environment]::OSVersion.Version
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $isServer = $osInfo.ProductType -ne 1
        
        # Windows 10 is version 10.0, Server 2016 is also 10.0
        $requirements.WindowsVersion = $osVersion.Major -ge 10
        
        if ($requirements.WindowsVersion) {
            $osName = if ($isServer) { "Windows Server" } else { "Windows" }
            Write-InstallationLog -Level Success -Message "✓ $osName version $($osVersion.ToString()) meets requirements (10.0+)"
            $requirementDetails.WindowsVersion = "$osName $($osVersion.ToString())"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Windows 10 or Windows Server 2016 or higher required. Current: $($osVersion.ToString())"
            Write-InstallationLog -Level Error -Message "SOLUTION: Upgrade to Windows 10 or Windows Server 2016 or later"
            $requirementDetails.WindowsVersion = "Windows $($osVersion.ToString()) - Upgrade required"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking Windows features" -SubStepNumber 5 -TotalSubSteps 9
        
        # Check Windows features
        $requirements.WindowsFeatures = Test-WindowsFeatures
        if ($requirements.WindowsFeatures) {
            Write-InstallationLog -Level Success -Message "✓ Required Windows features are available"
            $requirementDetails.WindowsFeatures = "All required features available"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Some Windows features may need configuration"
            $requirementDetails.WindowsFeatures = "Features may need configuration"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking available memory" -SubStepNumber 6 -TotalSubSteps 9
        
        # Check available memory (minimum 512MB free)
        try {
            $memoryInfo = Get-WmiObject -Class Win32_OperatingSystem
            $freeMemoryMB = [math]::Round($memoryInfo.FreePhysicalMemory / 1KB, 2)
            $requirements.MemoryAvailable = $freeMemoryMB -ge 512
            
            if ($requirements.MemoryAvailable) {
                Write-InstallationLog -Level Success -Message "✓ Sufficient memory available: ${freeMemoryMB}MB free (512MB+ required)"
                $requirementDetails.MemoryAvailable = "${freeMemoryMB}MB available"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Low memory: ${freeMemoryMB}MB free (512MB+ recommended)"
                Write-InstallationLog -Level Info -Message "SOLUTION: Close unnecessary applications to free up memory"
                $requirementDetails.MemoryAvailable = "${freeMemoryMB}MB available - Low memory"
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not check available memory: $($_.Exception.Message)"
            $requirements.MemoryAvailable = $true # Don't fail installation for this
            $requirementDetails.MemoryAvailable = "Memory check failed - proceeding"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking disk space" -SubStepNumber 7 -TotalSubSteps 9
        
        # Check available disk space (minimum 100MB)
        $installDrive = Split-Path $InstallPath -Qualifier
        $driveInfo = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DeviceID -eq $installDrive }
        if ($driveInfo) {
            $freeSpaceMB = [math]::Round($driveInfo.FreeSpace / 1MB, 2)
            $requirements.DiskSpace = $freeSpaceMB -ge 100
            
            if ($requirements.DiskSpace) {
                Write-InstallationLog -Level Success -Message "✓ Sufficient disk space on $installDrive`: ${freeSpaceMB}MB free (100MB+ required)"
                $requirementDetails.DiskSpace = "${freeSpaceMB}MB available on $installDrive"
            }
            else {
                Write-InstallationLog -Level Error -Message "✗ Insufficient disk space on $installDrive`: ${freeSpaceMB}MB free (100MB+ required)"
                Write-InstallationLog -Level Error -Message "SOLUTION: Free up disk space on $installDrive or choose a different installation path"
                $requirementDetails.DiskSpace = "${freeSpaceMB}MB available on $installDrive - Insufficient"
            }
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Could not check disk space for drive $installDrive"
            $requirements.DiskSpace = $true # Don't fail installation for this
            $requirementDetails.DiskSpace = "Disk space check failed - proceeding"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking .NET runtime" -SubStepNumber 8 -TotalSubSteps 9
        
        # Check .NET runtime (will be installed if missing)
        $requirements.DotNetRuntime = Test-DotNetRuntime
        if ($requirements.DotNetRuntime) {
            Write-InstallationLog -Level Success -Message "✓ Compatible .NET runtime found"
            $requirementDetails.DotNetRuntime = "Compatible .NET runtime available"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ No compatible .NET runtime found - will install during prerequisites"
            $requirementDetails.DotNetRuntime = "Will install .NET runtime"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking network connectivity" -SubStepNumber 9 -TotalSubSteps 9
        
        # Check network access to GitHub and platform
        $requirements.NetworkAccess = Test-NetworkConnectivity
        if ($requirements.NetworkAccess) {
            Write-InstallationLog -Level Success -Message "✓ Network connectivity to required services confirmed"
            $requirementDetails.NetworkAccess = "Network connectivity confirmed"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Network connectivity issues detected"
            Write-InstallationLog -Level Info -Message "SOLUTION: Check internet connection and firewall settings"
            $requirementDetails.NetworkAccess = "Network connectivity issues"
        }
        
        # Summary of requirements check
        $passedRequirements = $requirements.GetEnumerator() | Where-Object { $_.Value } | ForEach-Object { $_.Key }
        $failedRequirements = $requirements.GetEnumerator() | Where-Object { -not $_.Value } | ForEach-Object { $_.Key }
        $criticalFailures = $failedRequirements | Where-Object { $_ -in @('AdminRights', 'PowerShellVersion', 'WindowsVersion', 'DiskSpace') }
        
        Write-InstallationLog -Level Info -Message "Requirements Summary:"
        Write-InstallationLog -Level Info -Message "  Passed: $($passedRequirements.Count)/$($requirements.Count) requirements"
        if ($failedRequirements.Count -gt 0) {
            Write-InstallationLog -Level Warning -Message "  Failed: $($failedRequirements -join ', ')"
        }
        
        # Store detailed requirements for diagnostics
        $script:SystemRequirementsDetails = $requirementDetails
        
        if ($criticalFailures.Count -eq 0) {
            Write-InstallationLog -Level Success -Message "✓ All critical system requirements validated successfully"
            if ($failedRequirements.Count -gt 0) {
                Write-InstallationLog -Level Info -Message "Non-critical issues will be addressed during installation"
            }
            return $true
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Critical system requirements not met: $($criticalFailures -join ', ')"
            Write-InstallationLog -Level Error -Message "Please resolve the issues above and run the installation command again"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during system requirements validation: $($_.Exception.Message)"
        return $false
    }
}

function Test-DotNetRuntime {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking .NET runtime availability..."
    
    try {
        # Check for .NET Framework 4.7.2 or higher, or .NET Core/5+
        $dotNetVersions = @()
        
        # Check .NET Framework
        $frameworkPath = "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full"
        if (Test-Path $frameworkPath) {
            $release = Get-ItemProperty -Path $frameworkPath -Name Release -ErrorAction SilentlyContinue
            if ($release -and $release.Release -ge 461808) { # .NET Framework 4.7.2
                $dotNetVersions += ".NET Framework 4.7.2+"
                Write-InstallationLog -Level Debug -Message "Found .NET Framework 4.7.2+ (Release: $($release.Release))"
            }
        }
        
        # Check .NET Core/.NET 5+
        try {
            $dotnetInfo = & dotnet --info 2>$null
            if ($LASTEXITCODE -eq 0) {
                $dotNetVersions += ".NET Core/5+"
                Write-InstallationLog -Level Debug -Message "Found .NET Core/5+ runtime"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "dotnet command not found or failed"
        }
        
        if ($dotNetVersions.Count -gt 0) {
            Write-InstallationLog -Level Info -Message "Found compatible .NET runtime: $($dotNetVersions -join ', ')"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "No compatible .NET runtime found. Will attempt to install during prerequisites."
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking .NET runtime: $($_.Exception.Message)"
        return $false
    }
}

function Test-WindowsFeatures {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking required Windows features..."
    
    try {
        $requiredFeatures = @()
        $missingFeatures = @()
        
        # Check if we're on Windows Server (may need different features)
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $isServer = $osInfo.ProductType -ne 1
        
        if ($isServer) {
            Write-InstallationLog -Level Debug -Message "Detected Windows Server environment"
            # Server-specific feature checks could go here
        }
        else {
            Write-InstallationLog -Level Debug -Message "Detected Windows Client environment"
        }
        
        # Check Windows Service support (should be available by default)
        try {
            $serviceManager = Get-Service -Name "Spooler" -ErrorAction SilentlyContinue
            if ($serviceManager) {
                Write-InstallationLog -Level Debug -Message "Windows Service Manager is available"
            }
            else {
                $missingFeatures += "Windows Service Manager"
            }
        }
        catch {
            $missingFeatures += "Windows Service Manager"
        }
        
        # Check Windows Event Log support
        try {
            $eventLogService = Get-Service -Name "EventLog" -ErrorAction SilentlyContinue
            if ($eventLogService -and $eventLogService.Status -eq 'Running') {
                Write-InstallationLog -Level Debug -Message "Windows Event Log service is running"
            }
            else {
                Write-InstallationLog -Level Warning -Message "Windows Event Log service is not running"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check Windows Event Log service"
        }
        
        if ($missingFeatures.Count -eq 0) {
            Write-InstallationLog -Level Info -Message "All required Windows features are available"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "Missing Windows features: $($missingFeatures -join ', ')"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking Windows features: $($_.Exception.Message)"
        return $false
    }
}

function Test-PowerShellExecutionPolicy {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking PowerShell execution policy..."
    
    try {
        $currentPolicy = Get-ExecutionPolicy -Scope CurrentUser
        $machinePolicy = Get-ExecutionPolicy -Scope LocalMachine
        
        Write-InstallationLog -Level Debug -Message "Current user execution policy: $currentPolicy"
        Write-InstallationLog -Level Debug -Message "Machine execution policy: $machinePolicy"
        
        # Check if execution policy allows script execution
        $allowedPolicies = @('Unrestricted', 'RemoteSigned', 'AllSigned', 'Bypass')
        
        if ($currentPolicy -in $allowedPolicies -or $machinePolicy -in $allowedPolicies) {
            Write-InstallationLog -Level Info -Message "PowerShell execution policy allows script execution"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "PowerShell execution policy may prevent script execution. Current: $currentPolicy, Machine: $machinePolicy"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking PowerShell execution policy: $($_.Exception.Message)"
        return $false
    }
} -Message "Error checking .NET runtime: $($_.Exception.Message)"
        return $false
    }
}

function Test-NetworkConnectivity {
    [CmdletBinding()]
    param()
    
    $testUrls = @(
        "https://api.github.com",
        "https://github.com",
        $PlatformEndpoint
    )
    
    $allSuccessful = $true
    
    foreach ($url in $testUrls) {
        try {
            $response = Invoke-WebRequest -Uri $url -Method Head -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop
            Write-InstallationLog -Level Debug -Message "Network connectivity test successful: $url"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Network connectivity test failed for $url`: $($_.Exception.Message)"
            $allSuccessful = $false
        }
    }
    
    return $allSuccessful
}

# ================================================================
# Error Handling and Rollback Functions
# ================================================================

function Invoke-WithRetry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory=$false)]
        [int]$MaxRetries = 3,
        
        [Parameter(Mandatory=$false)]
        [int]$DelaySeconds = 5,
        
        [Parameter(Mandatory=$false)]
        [string]$OperationName = "Operation"
    )
    
    $attempt = 1
    
    while ($attempt -le $MaxRetries) {
        try {
            Write-InstallationLog -Level Debug -Message "$OperationName attempt $attempt of $MaxRetries"
            $result = & $ScriptBlock
            Write-InstallationLog -Level Debug -Message "$OperationName succeeded on attempt $attempt"
            return $result
        }
        catch {
            Write-InstallationLog -Level Warning -Message "$OperationName failed on attempt $attempt`: $($_.Exception.Message)"
            
            if ($attempt -eq $MaxRetries) {
                Write-InstallationLog -Level Error -Message "$OperationName failed after $MaxRetries attempts"
                throw
            }
            
            $delay = $DelaySeconds * [math]::Pow(2, $attempt - 1) # Exponential backoff
            Write-InstallationLog -Level Info -Message "Retrying in $delay seconds..."
            Start-Sleep -Seconds $delay
            $attempt++
        }
    }
}

function Invoke-InstallationRollback {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$InstallationId,
        
        [Parameter(Mandatory=$false)]
        [string]$Reason = "Installation failed"
    )
    
    Write-InstallationLog -Level Warning -Message "Initiating installation rollback: $Reason"
    
    try {
        # Stop and remove service if it was created
        if (Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue) {
            Write-InstallationLog -Level Info -Message "Stopping and removing RepSet Bridge service..."
            try {
                Stop-BridgeService -ServiceName $script:ServiceName -Force -ErrorAction SilentlyContinue
                Remove-BridgeService -ServiceName $script:ServiceName -ErrorAction SilentlyContinue
            }
            catch {
                Write-InstallationLog -Level Warning -Message "Could not cleanly remove service during rollback: $($_.Exception.Message)"
                # Fallback to direct sc.exe commands
                Stop-Service -Name $script:ServiceName -Force -ErrorAction SilentlyContinue
                & sc.exe delete $script:ServiceName | Out-Null
            }
        }
        
        # Restore configuration backup if it exists
        $configFile = Join-Path $InstallPath "config\$script:ConfigFileName"
        if (Test-Path $configFile) {
            $backupFiles = Get-ChildItem -Path (Split-Path $configFile) -Filter "*.backup.*" | Sort-Object LastWriteTime -Descending
            if ($backupFiles) {
                $latestBackup = $backupFiles[0]
                try {
                    Copy-Item -Path $latestBackup.FullName -Destination $configFile -Force
                    Write-InstallationLog -Level Info -Message "Restored configuration from backup: $($latestBackup.Name)"
                }
                catch {
                    Write-InstallationLog -Level Warning -Message "Could not restore configuration backup: $($_.Exception.Message)"
                }
            }
        }
        
        # Restore executable backup if it exists
        $executableFile = Join-Path $InstallPath "repset-bridge.exe"
        if (Test-Path $executableFile) {
            $backupFiles = Get-ChildItem -Path $InstallPath -Filter "*.backup.*" | Sort-Object LastWriteTime -Descending
            if ($backupFiles) {
                $latestBackup = $backupFiles[0]
                try {
                    Copy-Item -Path $latestBackup.FullName -Destination $executableFile -Force
                    Write-InstallationLog -Level Info -Message "Restored executable from backup: $($latestBackup.Name)"
                }
                catch {
                    Write-InstallationLog -Level Warning -Message "Could not restore executable backup: $($_.Exception.Message)"
                }
            }
            else {
                # No backup available, remove the failed installation
                Remove-Item -Path $executableFile -Force -ErrorAction SilentlyContinue
                Write-InstallationLog -Level Info -Message "Removed failed executable installation"
            }
        }
        
        # If no backups were restored, remove the entire installation directory
        $hasValidBackups = $false
        if (Test-Path $InstallPath) {
            $backupFiles = Get-ChildItem -Path $InstallPath -Filter "*.backup.*" -Recurse
            if ($backupFiles.Count -eq 0) {
                Write-InstallationLog -Level Info -Message "No backups found, removing installation directory: $InstallPath"
                Remove-Item -Path $InstallPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            else {
                Write-InstallationLog -Level Info -Message "Preserved installation directory with backups"
                $hasValidBackups = $true
            }
        }
        
        # Clean up temporary files
        $tempFiles = Get-ChildItem -Path $env:TEMP -Filter "RepSetBridge-*" -ErrorAction SilentlyContinue
        foreach ($tempFile in $tempFiles) {
            try {
                Remove-Item -Path $tempFile.FullName -Force -ErrorAction SilentlyContinue
                Write-InstallationLog -Level Debug -Message "Cleaned up temporary file: $($tempFile.Name)"
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Could not clean up temporary file: $($tempFile.Name)"
            }
        }
        
        # Remove any registry entries (if we added any)
        $registryPath = "HKLM:\SOFTWARE\RepSet\Bridge"
        if (Test-Path $registryPath) {
            Write-InstallationLog -Level Info -Message "Removing registry entries"
            Remove-Item -Path $registryPath -Recurse -Force -ErrorAction SilentlyContinue
        }
        
        if ($hasValidBackups) {
            Write-InstallationLog -Level Success -Message "Installation rollback completed - previous version restored"
        }
        else {
            Write-InstallationLog -Level Success -Message "Installation rollback completed - failed installation removed"
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during rollback: $($_.Exception.Message)"
        throw
    }
}

# ================================================================
# System Requirements Validation Functions
# ================================================================

function Test-SystemRequirements {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Validating system requirements..."
    
    $requirements = @{
        AdminRights = $false
        PowerShellVersion = $false
        PowerShellExecutionPolicy = $false
        DotNetRuntime = $false
        WindowsVersion = $false
        WindowsFeatures = $false
        DiskSpace = $false
        NetworkAccess = $false
        MemoryAvailable = $false
    }
    
    $requirementDetails = @{}
    
    try {
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking administrator privileges" -SubStepNumber 1 -TotalSubSteps 9
        
        # Check if running as administrator
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        $requirements.AdminRights = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        
        if ($requirements.AdminRights) {
            Write-InstallationLog -Level Success -Message "✓ Running with Administrator privileges"
            $requirementDetails.AdminRights = "Administrator privileges confirmed"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Administrator privileges required"
            Write-InstallationLog -Level Error -Message "SOLUTION: Right-click PowerShell and select 'Run as Administrator', then run this command again."
            $requirementDetails.AdminRights = "Missing administrator privileges"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking PowerShell version" -SubStepNumber 2 -TotalSubSteps 9
        
        # Check PowerShell version (minimum 5.1)
        $psVersion = $PSVersionTable.PSVersion
        $requirements.PowerShellVersion = $psVersion.Major -ge 5 -and ($psVersion.Major -gt 5 -or $psVersion.Minor -ge 1)
        
        if ($requirements.PowerShellVersion) {
            Write-InstallationLog -Level Success -Message "✓ PowerShell version $($psVersion.ToString()) meets requirements (5.1+)"
            $requirementDetails.PowerShellVersion = "PowerShell $($psVersion.ToString())"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ PowerShell 5.1 or higher required. Current: $($psVersion.ToString())"
            Write-InstallationLog -Level Error -Message "SOLUTION: Install Windows Management Framework 5.1 or upgrade to PowerShell 7+"
            $requirementDetails.PowerShellVersion = "PowerShell $($psVersion.ToString()) - Upgrade required"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking execution policy" -SubStepNumber 3 -TotalSubSteps 9
        
        # Check PowerShell execution policy
        $requirements.PowerShellExecutionPolicy = Test-PowerShellExecutionPolicy
        if ($requirements.PowerShellExecutionPolicy) {
            Write-InstallationLog -Level Success -Message "✓ PowerShell execution policy allows script execution"
            $requirementDetails.PowerShellExecutionPolicy = "Execution policy allows scripts"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ PowerShell execution policy may restrict script execution"
            Write-InstallationLog -Level Info -Message "SOLUTION: Run 'Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser' if installation fails"
            $requirementDetails.PowerShellExecutionPolicy = "Execution policy may need adjustment"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking Windows version" -SubStepNumber 4 -TotalSubSteps 9
        
        # Check Windows version (minimum Windows 10 / Server 2016)
        $osVersion = [System.Environment]::OSVersion.Version
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $isServer = $osInfo.ProductType -ne 1
        
        # Windows 10 is version 10.0, Server 2016 is also 10.0
        $requirements.WindowsVersion = $osVersion.Major -ge 10
        
        if ($requirements.WindowsVersion) {
            $osName = if ($isServer) { "Windows Server" } else { "Windows" }
            Write-InstallationLog -Level Success -Message "✓ $osName version $($osVersion.ToString()) meets requirements (10.0+)"
            $requirementDetails.WindowsVersion = "$osName $($osVersion.ToString())"
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Windows 10 or Windows Server 2016 or higher required. Current: $($osVersion.ToString())"
            Write-InstallationLog -Level Error -Message "SOLUTION: Upgrade to Windows 10 or Windows Server 2016 or later"
            $requirementDetails.WindowsVersion = "Windows $($osVersion.ToString()) - Upgrade required"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking Windows features" -SubStepNumber 5 -TotalSubSteps 9
        
        # Check Windows features
        $requirements.WindowsFeatures = Test-WindowsFeatures
        if ($requirements.WindowsFeatures) {
            Write-InstallationLog -Level Success -Message "✓ Required Windows features are available"
            $requirementDetails.WindowsFeatures = "All required features available"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Some Windows features may need configuration"
            $requirementDetails.WindowsFeatures = "Features may need configuration"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking available memory" -SubStepNumber 6 -TotalSubSteps 9
        
        # Check available memory (minimum 512MB free)
        try {
            $memoryInfo = Get-WmiObject -Class Win32_OperatingSystem
            $freeMemoryMB = [math]::Round($memoryInfo.FreePhysicalMemory / 1KB, 2)
            $requirements.MemoryAvailable = $freeMemoryMB -ge 512
            
            if ($requirements.MemoryAvailable) {
                Write-InstallationLog -Level Success -Message "✓ Sufficient memory available: ${freeMemoryMB}MB free (512MB+ required)"
                $requirementDetails.MemoryAvailable = "${freeMemoryMB}MB available"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Low memory: ${freeMemoryMB}MB free (512MB+ recommended)"
                Write-InstallationLog -Level Info -Message "SOLUTION: Close unnecessary applications to free up memory"
                $requirementDetails.MemoryAvailable = "${freeMemoryMB}MB available - Low memory"
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not check available memory: $($_.Exception.Message)"
            $requirements.MemoryAvailable = $true # Don't fail installation for this
            $requirementDetails.MemoryAvailable = "Memory check failed - proceeding"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking disk space" -SubStepNumber 7 -TotalSubSteps 9
        
        # Check available disk space (minimum 100MB)
        $installDrive = Split-Path $InstallPath -Qualifier
        $driveInfo = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DeviceID -eq $installDrive }
        if ($driveInfo) {
            $freeSpaceMB = [math]::Round($driveInfo.FreeSpace / 1MB, 2)
            $requirements.DiskSpace = $freeSpaceMB -ge 100
            
            if ($requirements.DiskSpace) {
                Write-InstallationLog -Level Success -Message "✓ Sufficient disk space on $installDrive`: ${freeSpaceMB}MB free (100MB+ required)"
                $requirementDetails.DiskSpace = "${freeSpaceMB}MB available on $installDrive"
            }
            else {
                Write-InstallationLog -Level Error -Message "✗ Insufficient disk space on $installDrive`: ${freeSpaceMB}MB free (100MB+ required)"
                Write-InstallationLog -Level Error -Message "SOLUTION: Free up disk space on $installDrive or choose a different installation path"
                $requirementDetails.DiskSpace = "${freeSpaceMB}MB available on $installDrive - Insufficient"
            }
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Could not check disk space for drive $installDrive"
            $requirements.DiskSpace = $true # Don't fail installation for this
            $requirementDetails.DiskSpace = "Disk space check failed - proceeding"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking .NET runtime" -SubStepNumber 8 -TotalSubSteps 9
        
        # Check .NET runtime (will be installed if missing)
        $requirements.DotNetRuntime = Test-DotNetRuntime
        if ($requirements.DotNetRuntime) {
            Write-InstallationLog -Level Success -Message "✓ Compatible .NET runtime found"
            $requirementDetails.DotNetRuntime = "Compatible .NET runtime available"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ No compatible .NET runtime found - will install during prerequisites"
            $requirementDetails.DotNetRuntime = "Will install .NET runtime"
        }
        
        Write-Progress-Step -Step "System Requirements Validation" -StepNumber 1 -TotalSteps 1 -Status "Checking network connectivity" -SubStepNumber 9 -TotalSubSteps 9
        
        # Check network access to GitHub and platform
        $requirements.NetworkAccess = Test-NetworkConnectivity
        if ($requirements.NetworkAccess) {
            Write-InstallationLog -Level Success -Message "✓ Network connectivity to required services confirmed"
            $requirementDetails.NetworkAccess = "Network connectivity confirmed"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Network connectivity issues detected"
            Write-InstallationLog -Level Info -Message "SOLUTION: Check internet connection and firewall settings"
            $requirementDetails.NetworkAccess = "Network connectivity issues"
        }
        
        # Summary of requirements check
        $passedRequirements = $requirements.GetEnumerator() | Where-Object { $_.Value } | ForEach-Object { $_.Key }
        $failedRequirements = $requirements.GetEnumerator() | Where-Object { -not $_.Value } | ForEach-Object { $_.Key }
        $criticalFailures = $failedRequirements | Where-Object { $_ -in @('AdminRights', 'PowerShellVersion', 'WindowsVersion', 'DiskSpace') }
        
        Write-InstallationLog -Level Info -Message "Requirements Summary:"
        Write-InstallationLog -Level Info -Message "  Passed: $($passedRequirements.Count)/$($requirements.Count) requirements"
        if ($failedRequirements.Count -gt 0) {
            Write-InstallationLog -Level Warning -Message "  Failed: $($failedRequirements -join ', ')"
        }
        
        # Store detailed requirements for diagnostics
        $script:SystemRequirementsDetails = $requirementDetails
        
        if ($criticalFailures.Count -eq 0) {
            Write-InstallationLog -Level Success -Message "✓ All critical system requirements validated successfully"
            if ($failedRequirements.Count -gt 0) {
                Write-InstallationLog -Level Info -Message "Non-critical issues will be addressed during installation"
            }
            return $true
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Critical system requirements not met: $($criticalFailures -join ', ')"
            Write-InstallationLog -Level Error -Message "Please resolve the issues above and run the installation command again"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during system requirements validation: $($_.Exception.Message)"
        return $false
    }
}

function Test-DotNetRuntime {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking .NET runtime availability..."
    
    try {
        # Check for .NET Framework 4.7.2 or higher, or .NET Core/5+
        $dotNetVersions = @()
        
        # Check .NET Framework
        $frameworkPath = "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full"
        if (Test-Path $frameworkPath) {
            $release = Get-ItemProperty -Path $frameworkPath -Name Release -ErrorAction SilentlyContinue
            if ($release -and $release.Release -ge 461808) { # .NET Framework 4.7.2
                $dotNetVersions += ".NET Framework 4.7.2+"
                Write-InstallationLog -Level Debug -Message "Found .NET Framework 4.7.2+ (Release: $($release.Release))"
            }
        }
        
        # Check .NET Core/.NET 5+
        try {
            $dotnetInfo = & dotnet --info 2>$null
            if ($LASTEXITCODE -eq 0) {
                $dotNetVersions += ".NET Core/5+"
                Write-InstallationLog -Level Debug -Message "Found .NET Core/5+ runtime"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "dotnet command not found or failed"
        }
        
        if ($dotNetVersions.Count -gt 0) {
            Write-InstallationLog -Level Info -Message "Found compatible .NET runtime: $($dotNetVersions -join ', ')"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "No compatible .NET runtime found. Will attempt to install during prerequisites."
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking .NET runtime: $($_.Exception.Message)"
        return $false
    }
}

function Test-WindowsFeatures {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking required Windows features..."
    
    try {
        $requiredFeatures = @()
        $missingFeatures = @()
        
        # Check if we're on Windows Server (may need different features)
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $isServer = $osInfo.ProductType -ne 1
        
        if ($isServer) {
            Write-InstallationLog -Level Debug -Message "Detected Windows Server environment"
            # Server-specific feature checks could go here
        }
        else {
            Write-InstallationLog -Level Debug -Message "Detected Windows Client environment"
        }
        
        # Check Windows Service support (should be available by default)
        try {
            $serviceManager = Get-Service -Name "Spooler" -ErrorAction SilentlyContinue
            if ($serviceManager) {
                Write-InstallationLog -Level Debug -Message "Windows Service Manager is available"
            }
            else {
                $missingFeatures += "Windows Service Manager"
            }
        }
        catch {
            $missingFeatures += "Windows Service Manager"
        }
        
        # Check Windows Event Log support
        try {
            $eventLogService = Get-Service -Name "EventLog" -ErrorAction SilentlyContinue
            if ($eventLogService -and $eventLogService.Status -eq 'Running') {
                Write-InstallationLog -Level Debug -Message "Windows Event Log service is running"
            }
            else {
                Write-InstallationLog -Level Warning -Message "Windows Event Log service is not running"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check Windows Event Log service"
        }
        
        if ($missingFeatures.Count -eq 0) {
            Write-InstallationLog -Level Info -Message "All required Windows features are available"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "Missing Windows features: $($missingFeatures -join ', ')"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking Windows features: $($_.Exception.Message)"
        return $false
    }
}

function Test-PowerShellExecutionPolicy {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Debug -Message "Checking PowerShell execution policy..."
    
    try {
        $currentPolicy = Get-ExecutionPolicy -Scope CurrentUser
        $machinePolicy = Get-ExecutionPolicy -Scope LocalMachine
        
        Write-InstallationLog -Level Debug -Message "Current user execution policy: $currentPolicy"
        Write-InstallationLog -Level Debug -Message "Machine execution policy: $machinePolicy"
        
        # Check if execution policy allows script execution
        $allowedPolicies = @('Unrestricted', 'RemoteSigned', 'AllSigned', 'Bypass')
        
        if ($currentPolicy -in $allowedPolicies -or $machinePolicy -in $allowedPolicies) {
            Write-InstallationLog -Level Info -Message "PowerShell execution policy allows script execution"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "PowerShell execution policy may prevent script execution. Current: $currentPolicy, Machine: $machinePolicy"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Error checking PowerShell execution policy: $($_.Exception.Message)"
        return $false
    }
}

function Test-NetworkConnectivity {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string[]]$TestUrls = @(
            "https://api.github.com",
            "https://github.com",
            $PlatformEndpoint
        )
    )
    
    Write-InstallationLog -Level Debug -Message "Testing network connectivity to required services..."
    
    $testUrls = @(
        "https://api.github.com",
        "https://github.com",
        $PlatformEndpoint
    )
    
    $connectivityResults = @{}
    $allSuccessful = $true
    
    foreach ($url in $testUrls) {
        try {
            Write-InstallationLog -Level Debug -Message "Testing connectivity to: $url"
            
            # Use HEAD request for faster testing
            $response = Invoke-WebRequest -Uri $url -Method Head -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop
            
            $connectivityResults[$url] = @{
                Success = $true
                StatusCode = $response.StatusCode
                ResponseTime = $null
            }
            
            Write-InstallationLog -Level Debug -Message "✓ Network connectivity successful: $url (Status: $($response.StatusCode))"
        }
        catch {
            $connectivityResults[$url] = @{
                Success = $false
                Error = $_.Exception.Message
                StatusCode = $null
            }
            
            Write-InstallationLog -Level Warning -Message "✗ Network connectivity failed for $url`: $($_.Exception.Message)"
            $allSuccessful = $false
            
            # Provide specific troubleshooting guidance
            if ($_.Exception.Message -like "*timeout*") {
                Write-InstallationLog -Level Info -Message "  SOLUTION: Check internet connection and DNS resolution"
            }
            elseif ($_.Exception.Message -like "*SSL*" -or $_.Exception.Message -like "*TLS*") {
                Write-InstallationLog -Level Info -Message "  SOLUTION: Check system date/time and certificate store"
            }
            elseif ($_.Exception.Message -like "*proxy*") {
                Write-InstallationLog -Level Info -Message "  SOLUTION: Configure proxy settings or bypass proxy for this URL"
            }
            elseif ($_.Exception.Message -like "*firewall*" -or $_.Exception.Message -like "*blocked*") {
                Write-InstallationLog -Level Info -Message "  SOLUTION: Configure firewall to allow outbound HTTPS connections"
            }
            else {
                Write-InstallationLog -Level Info -Message "  SOLUTION: Verify internet connection and try again"
            }
        }
    }
    
    # Additional network diagnostics
    if (-not $allSuccessful) {
        Write-InstallationLog -Level Info -Message "Running additional network diagnostics..."
        
        # Test basic internet connectivity
        try {
            $dnsTest = Resolve-DnsName -Name "google.com" -ErrorAction Stop
            Write-InstallationLog -Level Debug -Message "✓ DNS resolution working"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "✗ DNS resolution failed: $($_.Exception.Message)"
            Write-InstallationLog -Level Info -Message "  SOLUTION: Check DNS server settings"
        }
        
        # Check proxy settings
        try {
            $proxySettings = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings" -ErrorAction SilentlyContinue
            if ($proxySettings -and $proxySettings.ProxyEnable -eq 1) {
                Write-InstallationLog -Level Info -Message "Proxy detected: $($proxySettings.ProxyServer)"
                Write-InstallationLog -Level Info -Message "  NOTE: Ensure proxy allows access to GitHub and RepSet platform"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check proxy settings"
        }
    }
    
    # Store connectivity results for diagnostics
    $script:NetworkConnectivityResults = $connectivityResults
    
    if ($allSuccessful) {
        Write-InstallationLog -Level Success -Message "✓ All network connectivity tests passed"
    }
    else {
        Write-InstallationLog -Level Warning -Message "⚠ Some network connectivity tests failed - installation may encounter issues"
    }
    
    return $allSuccessful
}

# ================================================================
# Prerequisites Installation Functions
# ================================================================

function Install-Prerequisites {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Installing and configuring prerequisites..."
    
    $prerequisiteSteps = 4
    $currentStep = 0
    $installationResults = @{
        DotNetRuntime = $false
        PowerShellExecutionPolicy = $false
        WindowsFeatures = $false
        SystemConfiguration = $false
    }
    
    try {
        # Step 1: Install .NET Runtime if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Installing .NET Runtime" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-DotNetRuntime)) {
            Write-InstallationLog -Level Info -Message "Installing .NET Runtime..."
            $installationResults.DotNetRuntime = Install-DotNetRuntime
            
            if ($installationResults.DotNetRuntime) {
                Write-InstallationLog -Level Success -Message "✓ .NET Runtime installed successfully"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ .NET Runtime installation failed - bridge may not function properly"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ .NET Runtime already available"
            $installationResults.DotNetRuntime = $true
        }
        
        # Step 2: Configure PowerShell execution policy if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Configuring PowerShell" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-PowerShellExecutionPolicy)) {
            Write-InstallationLog -Level Info -Message "Configuring PowerShell execution policy..."
            $installationResults.PowerShellExecutionPolicy = Set-PowerShellExecutionPolicy
            
            if ($installationResults.PowerShellExecutionPolicy) {
                Write-InstallationLog -Level Success -Message "✓ PowerShell execution policy configured"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ PowerShell execution policy configuration failed"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ PowerShell execution policy already configured"
            $installationResults.PowerShellExecutionPolicy = $true
        }
        
        # Step 3: Configure Windows features if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Configuring Windows features" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-WindowsFeatures)) {
            Write-InstallationLog -Level Info -Message "Configuring Windows features..."
            $installationResults.WindowsFeatures = Install-WindowsFeatures
            
            if ($installationResults.WindowsFeatures) {
                Write-InstallationLog -Level Success -Message "✓ Windows features configured"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows features configuration completed with warnings"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ Windows features already configured"
            $installationResults.WindowsFeatures = $true
        }
        
        # Step 4: Apply system configuration optimizations
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Optimizing system configuration" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        Write-InstallationLog -Level Info -Message "Applying system configuration optimizations..."
        $installationResults.SystemConfiguration = Optimize-SystemConfiguration
        
        if ($installationResults.SystemConfiguration) {
            Write-InstallationLog -Level Success -Message "✓ System configuration optimized"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ System configuration optimization completed with warnings"
        }
        
        # Summary
        $successfulSteps = $installationResults.Values | Where-Object { $_ } | Measure-Object | Select-Object -ExpandProperty Count
        $totalSteps = $installationResults.Count
        
        Write-InstallationLog -Level Info -Message "Prerequisites installation summary: $successfulSteps/$totalSteps steps completed successfully"
        
        # Check if any critical prerequisites failed
        $criticalFailures = @()
        if (-not $installationResults.DotNetRuntime -and -not (Test-DotNetRuntime)) {
            $criticalFailures += ".NET Runtime"
        }
        
        if ($criticalFailures.Count -eq 0) {
            Write-InstallationLog -Level Success -Message "✓ All prerequisites installed and configured successfully"
            return $true
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Critical prerequisites failed: $($criticalFailures -join ', ')"
            Write-InstallationLog -Level Error -Message "Installation may fail or bridge may not function properly"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during prerequisites installation: $($_.Exception.Message)"
        return $false
    }
}

function Install-DotNetRuntime {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Downloading and installing .NET Runtime..."
    
    try {
        # Define .NET Runtime download URLs (latest stable versions)
        $dotNetRuntimes = @{
            "Framework" = @{
                Url = "https://download.microsoft.com/download/6/E/4/6E48E8AB-DC00-419E-9704-06DD46E5F81D/NDP472-KB4054530-x86-x64-AllOS-ENU.exe"
                FileName = "NDP472-KB4054530-x86-x64-AllOS-ENU.exe"
                Version = "4.7.2"
                Arguments = "/quiet /norestart"
            }
            "Core" = @{
                Url = "https://download.microsoft.com/download/1/7/2/172fab2a-6d0b-4b5d-9b8a-8e8b8b8b8b8b/windowsdesktop-runtime-6.0.25-win-x64.exe"
                FileName = "windowsdesktop-runtime-6.0.25-win-x64.exe"
                Version = "6.0"
                Arguments = "/quiet /norestart"
            }
        }
        
        # Try to install .NET Framework 4.7.2 first (most compatible)
        $frameworkRuntime = $dotNetRuntimes.Framework
        $downloadPath = Join-Path $env:TEMP $frameworkRuntime.FileName
        
        try {
            Write-InstallationLog -Level Info -Message "Downloading .NET Framework $($frameworkRuntime.Version)..."
            
            # Download with retry logic
            Invoke-WithRetry -OperationName ".NET Framework download" -MaxRetries 3 -ScriptBlock {
                $webClient = New-Object System.Net.WebClient
                try {
                    $webClient.Headers.Add('User-Agent', 'RepSet-Bridge-Installer/1.0')
                    $webClient.DownloadFile($frameworkRuntime.Url, $downloadPath)
                }
                finally {
                    $webClient.Dispose()
                }
            }
            
            if (Test-Path $downloadPath) {
                Write-InstallationLog -Level Info -Message "Installing .NET Framework $($frameworkRuntime.Version)..."
                
                # Run installer
                $process = Start-Process -FilePath $downloadPath -ArgumentList $frameworkRuntime.Arguments -Wait -PassThru -NoNewWindow
                
                if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 3010) { # 3010 = reboot required
                    Write-InstallationLog -Level Success -Message ".NET Framework $($frameworkRuntime.Version) installed successfully"
                    
                    if ($process.ExitCode -eq 3010) {
                        Write-InstallationLog -Level Warning -Message "System reboot may be required for .NET Framework to function properly"
                    }
                    
                    # Clean up installer
                    Remove-Item $downloadPath -Force -ErrorAction SilentlyContinue
                    
                    # Verify installation
                    Start-Sleep -Seconds 2
                    if (Test-DotNetRuntime) {
                        return $true
                    }
                    else {
                        Write-InstallationLog -Level Warning -Message ".NET Framework installed but verification failed"
                        return $false
                    }
                }
                else {
                    Write-InstallationLog -Level Error -Message ".NET Framework installation failed with exit code: $($process.ExitCode)"
                    return $false
                }
            }
            else {
                Write-InstallationLog -Level Error -Message ".NET Framework download failed"
                return $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message ".NET Framework installation failed: $($_.Exception.Message)"
            
            # Clean up failed download
            if (Test-Path $downloadPath) {
                Remove-Item $downloadPath -Force -ErrorAction SilentlyContinue
            }
            
            # Fall back to manual instructions
            Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Please install .NET Framework 4.7.2 or later from:"
            Write-InstallationLog -Level Info -Message "https://dotnet.microsoft.com/download/dotnet-framework"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during .NET Runtime installation: $($_.Exception.Message)"
        Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Please install .NET Framework 4.7.2 or later manually"
        return $false
    }
}

function Set-PowerShellExecutionPolicy {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Configuring PowerShell execution policy..."
    
    try {
        # Try to set execution policy for current user first (doesn't require admin for this scope)
        try {
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force -ErrorAction Stop
            Write-InstallationLog -Level Success -Message "PowerShell execution policy set to RemoteSigned for current user"
            
            # Verify the change
            if (Test-PowerShellExecutionPolicy) {
                return $true
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set execution policy for current user: $($_.Exception.Message)"
        }
        
        # Try to set execution policy for local machine (requires admin)
        try {
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine -Force -ErrorAction Stop
            Write-InstallationLog -Level Success -Message "PowerShell execution policy set to RemoteSigned for local machine"
            
            # Verify the change
            if (Test-PowerShellExecutionPolicy) {
                return $true
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set execution policy for local machine: $($_.Exception.Message)"
        }
        
        # If both failed, provide manual instructions
        Write-InstallationLog -Level Warning -Message "Could not automatically configure PowerShell execution policy"
        Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Run the following command in an elevated PowerShell:"
        Write-InstallationLog -Level Info -Message "Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine"
        
        return $false
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error configuring PowerShell execution policy: $($_.Exception.Message)"
        return $false
    }
}

function Install-WindowsFeatures {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Configuring Windows features and services..."
    
    try {
        $configurationSuccess = $true
        
        # Ensure Windows Service Manager is running
        try {
            $serviceManager = Get-Service -Name "Spooler" -ErrorAction SilentlyContinue
            if ($serviceManager) {
                Write-InstallationLog -Level Success -Message "✓ Windows Service Manager is available"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows Service Manager may not be available"
                $configurationSuccess = $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not verify Windows Service Manager"
            $configurationSuccess = $false
        }
        
        # Ensure Windows Event Log service is running
        try {
            $eventLogService = Get-Service -Name "EventLog" -ErrorAction SilentlyContinue
            if ($eventLogService) {
                if ($eventLogService.Status -ne 'Running') {
                    Write-InstallationLog -Level Info -Message "Starting Windows Event Log service..."
                    Start-Service -Name "EventLog" -ErrorAction Stop
                    Write-InstallationLog -Level Success -Message "✓ Windows Event Log service started"
                }
                else {
                    Write-InstallationLog -Level Success -Message "✓ Windows Event Log service is running"
                }
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows Event Log service not found"
                $configurationSuccess = $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not configure Windows Event Log service: $($_.Exception.Message)"
            $configurationSuccess = $false
        }
        
        # Configure Windows Firewall (if needed)
        try {
            Write-InstallationLog -Level Info -Message "Checking Windows Firewall configuration..."
            
            # Check if Windows Firewall service is running
            $firewallService = Get-Service -Name "MpsSvc" -ErrorAction SilentlyContinue
            if ($firewallService -and $firewallService.Status -eq 'Running') {
                Write-InstallationLog -Level Info -Message "Windows Firewall is active - bridge may need firewall rules"
                Write-InstallationLog -Level Info -Message "Note: Firewall rules will be configured when the bridge service starts"
            }
            else {
                Write-InstallationLog -Level Info -Message "Windows Firewall service not running or not found"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check Windows Firewall: $($_.Exception.Message)"
        }
        
        if ($configurationSuccess) {
            Write-InstallationLog -Level Success -Message "✓ Windows features configured successfully"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Windows features configuration completed with warnings"
        }
        
        return $configurationSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error configuring Windows features: $($_.Exception.Message)"
        return $false
    }
}

function Optimize-SystemConfiguration {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Applying system configuration optimizations..."
    
    try {
        $optimizationSuccess = $true
        
        # Set high-resolution timer (improves service performance)
        try {
            Write-InstallationLog -Level Debug -Message "Configuring system timer resolution..."
            # This is a placeholder for timer configuration
            # In a real implementation, we might configure multimedia timer resolution
            Write-InstallationLog -Level Debug -Message "Timer configuration completed"
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Timer configuration failed: $($_.Exception.Message)"
        }
        
        # Configure service recovery options (will be applied when service is created)
        try {
            Write-InstallationLog -Level Debug -Message "Preparing service recovery configuration..."
            $script:ServiceRecoveryConfig = @{
                FirstFailure = "restart"
                SecondFailure = "restart"
                SubsequentFailures = "none"
                RestartDelay = 60000  # 1 minute in milliseconds
                ResetFailureCount = 86400  # 24 hours in seconds
            }
            Write-InstallationLog -Level Debug -Message "Service recovery configuration prepared"
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Service recovery configuration failed: $($_.Exception.Message)"
        }
        
        # Create installation registry entries for tracking
        try {
            Write-InstallationLog -Level Debug -Message "Creating installation registry entries..."
            
            $registryPath = "HKLM:\SOFTWARE\RepSet\Bridge"
            if (-not (Test-Path $registryPath)) {
                New-Item -Path $registryPath -Force | Out-Null
            }
            
            # Store installation metadata
            Set-ItemProperty -Path $registryPath -Name "InstallationId" -Value $script:InstallationId -Type String
            Set-ItemProperty -Path $registryPath -Name "InstallationDate" -Value (Get-Date -Format 'yyyy-MM-dd HH:mm:ss') -Type String
            Set-ItemProperty -Path $registryPath -Name "InstalledBy" -Value "automated-installer" -Type String
            Set-ItemProperty -Path $registryPath -Name "GymId" -Value $GymId -Type String
            Set-ItemProperty -Path $registryPath -Name "PlatformEndpoint" -Value $PlatformEndpoint -Type String
            
            Write-InstallationLog -Level Debug -Message "Installation registry entries created"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not create registry entries: $($_.Exception.Message)"
            $optimizationSuccess = $false
        }
        
        # Configure system environment for service
        try {
            Write-InstallationLog -Level Debug -Message "Configuring system environment..."
            
            # Ensure TEMP directory is accessible
            $tempDir = $env:TEMP
            if (Test-Path $tempDir) {
                Write-InstallationLog -Level Debug -Message "TEMP directory accessible: $tempDir"
            }
            else {
                Write-InstallationLog -Level Warning -Message "TEMP directory not accessible: $tempDir"
                $optimizationSuccess = $false
            }
            
            Write-InstallationLog -Level Debug -Message "System environment configuration completed"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "System environment configuration failed: $($_.Exception.Message)"
            $optimizationSuccess = $false
        }
        
        if ($optimizationSuccess) {
            Write-InstallationLog -Level Success -Message "✓ System configuration optimized successfully"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ System configuration optimization completed with warnings"
        }
        
        return $optimizationSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during system configuration optimization: $($_.Exception.Message)"
        return $false
    }
}

# ================================================================
# Main Installation Function
# ================================================================

function Install-RepSetBridge {
    [CmdletBinding()]
    param()
    
    $totalSteps = 8
    $currentStep = 0
    $installationDetails = @{}
    
    try {
        # Initialize logging system
        Initialize-LoggingSystem
        
        # Send installation started notification
        Send-InstallationNotification -Status Started -Message "RepSet Bridge installation started" -Details @{
            gymId = $GymId
            installationId = $script:InstallationId
            platformEndpoint = $PlatformEndpoint
        }
        
        Write-InstallationLog -Level Info -Message "Starting RepSet Bridge installation (ID: $script:InstallationId)"
        Write-InstallationLog -Level Info -Message "Installation log: $script:LogFile"
        Write-InstallationLog -Level Info -Message "Gym ID: $GymId"
        Write-InstallationLog -Level Info -Message "Platform Endpoint: $PlatformEndpoint"
        Write-InstallationLog -Level Info -Message "Installation Path: $InstallPath"
        
        # Step 0: Check for existing installation and handle upgrade scenarios
        Write-Progress-Step -Step "Checking for existing installation" -StepNumber 0 -TotalSteps ($totalSteps + 1) -Status "Detecting existing bridge"
        
        $existingInstallation = Test-ExistingInstallation -InstallPath $InstallPath
        if ($existingInstallation.Found) {
            Write-InstallationLog -Level Info -Message "Existing installation detected - initiating upgrade process"
            
            $upgradeResult = Invoke-UpgradeInstallation -ExistingInstallation $existingInstallation -Force:$Force
            if (-not $upgradeResult) {
                throw "Upgrade process was cancelled or failed"
            }
            
            Write-InstallationLog -Level Success -Message "Upgrade preparation completed - proceeding with installation"
        }
        else {
            Write-InstallationLog -Level Info -Message "No existing installation found - proceeding with fresh installation"
        }
        
        $totalSteps = $totalSteps + 1  # Adjust total steps to account for the new step
        
        # Step 1: Validate command signature and expiration
        Write-Progress-Step -Step "Validating installation command" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Checking signature and expiration"
        
        if (-not (Test-CommandSignature -PairCode $PairCode -Signature $Signature -Nonce $Nonce -GymId $GymId -ExpiresAt $ExpiresAt)) {
            throw "Command validation failed"
        }
        
        if (-not (Test-CommandExpiration -ExpiresAt $ExpiresAt)) {
            throw "Command has expired"
        }
        
        Write-Progress-Step -Step "Validating installation command" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 2: Validate system requirements
        Write-Progress-Step -Step "Checking system requirements" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Validating prerequisites"
        
        if (-not $SkipPrerequisites -and -not (Test-SystemRequirements)) {
            throw "System requirements not met"
        }
        
        Write-Progress-Step -Step "Checking system requirements" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 3: Install prerequisites (if needed)
        Write-Progress-Step -Step "Installing prerequisites" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Installing required components"
        
        if (-not $SkipPrerequisites) {
            Install-Prerequisites
        }
        
        Write-Progress-Step -Step "Installing prerequisites" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 4: Download bridge executable
        Write-Progress-Step -Step "Downloading RepSet Bridge" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Fetching latest version"
        
        $bridgeInfo = Get-LatestBridge
        $installationDetails.bridgeVersion = $bridgeInfo.Version
        
        Write-Progress-Step -Step "Downloading RepSet Bridge" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Downloading executable"
        $bridgeExecutable = Get-BridgeExecutable -BridgeInfo $bridgeInfo
        
        Write-Progress-Step -Step "Downloading RepSet Bridge" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 5: Install bridge executable
        Write-Progress-Step -Step "Installing RepSet Bridge" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Copying files"
        
        $installedExecutable = Install-BridgeExecutable -ExecutablePath $bridgeExecutable -InstallPath $InstallPath
        $installationDetails.executablePath = $installedExecutable
        
        Write-Progress-Step -Step "Installing RepSet Bridge" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 6: Configure bridge
        Write-Progress-Step -Step "Configuring RepSet Bridge" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Creating configuration"
        
        $configFile = New-BridgeConfiguration -InstallPath $InstallPath -PairCode $PairCode -GymId $GymId -PlatformEndpoint $PlatformEndpoint
        $installationDetails.configFile = $configFile
        
        # Restore preserved configuration if this is an upgrade with configuration preservation
        if ($script:PreserveConfiguration -and $script:UpgradeBackupData -and $script:UpgradeBackupData.Success) {
            Write-InstallationLog -Level Info -Message "Preserving existing configuration settings..."
            Restore-ConfigurationSettings -BackupData $script:UpgradeBackupData -NewConfigPath $configFile
        }
        
        # Restore preserved configuration and logs from clean install scenario
        if ($script:PreservedConfigPath -or $script:PreservedLogsPath) {
            Write-InstallationLog -Level Info -Message "Restoring preserved configuration and logs..."
            Restore-PreservedConfiguration -InstallPath $InstallPath
        }
        
        Write-Progress-Step -Step "Configuring RepSet Bridge" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 7: Install and start service
        Write-Progress-Step -Step "Installing Windows service" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Creating service"
        
        Install-BridgeService -InstallPath $InstallPath -ExecutablePath (Join-Path $InstallPath "repset-bridge.exe")
        $installationDetails.serviceName = $script:ServiceName
        
        Write-Progress-Step -Step "Installing Windows service" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Starting service"
        Start-BridgeService -ValidateAutoStart
        
        Write-Progress-Step -Step "Installing Windows service" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        # Step 8: Verify installation and test connection
        Write-Progress-Step -Step "Verifying installation" -StepNumber (++$currentStep) -TotalSteps $totalSteps -Status "Running verification checks"
        
        # Basic service verification
        $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
        if ($service -and $service.Status -eq 'Running') {
            Write-InstallationLog -Level Success -Message "Service verification passed - bridge is running"
            $installationDetails.serviceStatus = "Running"
        }
        else {
            Write-InstallationLog -Level Warning -Message "Service verification warning - service may still be starting"
            $installationDetails.serviceStatus = if ($service) { $service.Status } else { "Not Found" }
        }
        
        # Platform connection verification
        Write-Progress-Step -Step "Verifying installation" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Testing platform connection"
        
        try {
            $connectionResult = Test-BridgeConnection -PlatformEndpoint $PlatformEndpoint -PairCode $PairCode -GymId $GymId -BridgeExecutablePath $installedExecutable -DetailedDiagnostics
            $installationDetails.connectionTest = $connectionResult
            
            if ($connectionResult.Success) {
                Write-InstallationLog -Level Success -Message "Platform connection test passed"
                $installationDetails.connectionStatus = "Connected"
            }
            else {
                Write-InstallationLog -Level Warning -Message "Platform connection test failed - bridge may still be initializing"
                $installationDetails.connectionStatus = "Failed"
                
                # Display troubleshooting guide for connection issues
                Write-ConnectionTroubleshootingGuide -ConnectionResult $connectionResult
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Connection test failed with exception: $($_.Exception.Message)"
            $installationDetails.connectionStatus = "Error"
            $installationDetails.connectionError = $_.Exception.Message
        }
        
        Write-Progress-Step -Step "Verifying installation" -StepNumber $currentStep -TotalSteps $totalSteps -Status "Completed"
        
        Write-Progress -Activity "RepSet Bridge Installation" -Completed
        
        # Generate installation summary
        Write-InstallationSummary -Success $true -InstallationDetails $installationDetails
        
        # Export diagnostics for successful installations (for support purposes)
        try {
            $diagnosticsPath = Export-InstallationDiagnostics
            if ($diagnosticsPath) {
                Write-InstallationLog -Level Info -Message "Installation diagnostics available at: $diagnosticsPath"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not export diagnostics: $($_.Exception.Message)"
        }
        
        return $script:ErrorCodes.Success
    }
    catch {
        $errorMessage = $_.Exception.Message
        Write-InstallationLog -Level Error -Message "Installation failed: $errorMessage"
        
        # Determine error code
        $errorCode = $script:ErrorCodes.InstallationFailed
        if ($errorMessage -like "*signature*" -or $errorMessage -like "*validation*") {
            $errorCode = $script:ErrorCodes.InvalidSignature
        }
        elseif ($errorMessage -like "*expired*") {
            $errorCode = $script:ErrorCodes.ExpiredCommand
        }
        elseif ($errorMessage -like "*requirements*") {
            $errorCode = $script:ErrorCodes.SystemRequirementsNotMet
        }
        elseif ($errorMessage -like "*download*" -or $errorMessage -like "*GitHub*") {
            $errorCode = $script:ErrorCodes.DownloadFailed
        }
        elseif ($errorMessage -like "*integrity*" -or $errorMessage -like "*hash*" -or $errorMessage -like "*checksum*") {
            $errorCode = $script:ErrorCodes.IntegrityVerificationFailed
        }
        elseif ($errorMessage -like "*service*" -or $errorMessage -like "*Service*") {
            $errorCode = $script:ErrorCodes.ServiceInstallationFailed
        }
        
        try {
            Write-InstallationLog -Level Info -Message "Initiating installation rollback..."
            
            # Use the enhanced rollback if we have backup data
            if ($script:UpgradeBackupData -and $script:UpgradeBackupData.Success) {
                $rollbackResult = Invoke-InstallationRollback -BackupInfo $script:UpgradeBackupData -RollbackReason $errorMessage
                if (-not $rollbackResult) {
                    Write-InstallationLog -Level Error -Message "Enhanced rollback failed"
                    $errorCode = $script:ErrorCodes.RollbackFailed
                }
            }
            else {
                # Fallback to basic rollback
                Invoke-InstallationRollback -InstallationId $script:InstallationId -Reason $errorMessage
            }
        }
        catch {
            Write-InstallationLog -Level Error -Message "Rollback also failed: $($_.Exception.Message)"
            $errorCode = $script:ErrorCodes.RollbackFailed
        }
        
        # Generate failure summary
        Write-InstallationSummary -Success $false -ErrorMessage $errorMessage -ErrorCode $errorCode -InstallationDetails $installationDetails
        
        # Export diagnostics for failed installations (for troubleshooting)
        try {
            $diagnosticsPath = Export-InstallationDiagnostics
            if ($diagnosticsPath) {
                Write-InstallationLog -Level Info -Message "Troubleshooting diagnostics available at: $diagnosticsPath"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not export diagnostics: $($_.Exception.Message)"
        }
        
        return $errorCode
    }
}

function Install-Prerequisites {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Installing and configuring prerequisites..."
    
    $prerequisiteSteps = 4
    $currentStep = 0
    $installationResults = @{
        DotNetRuntime = $false
        PowerShellExecutionPolicy = $false
        WindowsFeatures = $false
        SystemConfiguration = $false
    }
    
    try {
        # Step 1: Install .NET Runtime if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Installing .NET Runtime" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-DotNetRuntime)) {
            Write-InstallationLog -Level Info -Message "Installing .NET Runtime..."
            $installationResults.DotNetRuntime = Install-DotNetRuntime
            
            if ($installationResults.DotNetRuntime) {
                Write-InstallationLog -Level Success -Message "✓ .NET Runtime installed successfully"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ .NET Runtime installation failed - bridge may not function properly"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ .NET Runtime already available"
            $installationResults.DotNetRuntime = $true
        }
        
        # Step 2: Configure PowerShell execution policy if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Configuring PowerShell" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-PowerShellExecutionPolicy)) {
            Write-InstallationLog -Level Info -Message "Configuring PowerShell execution policy..."
            $installationResults.PowerShellExecutionPolicy = Set-PowerShellExecutionPolicy
            
            if ($installationResults.PowerShellExecutionPolicy) {
                Write-InstallationLog -Level Success -Message "✓ PowerShell execution policy configured"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ PowerShell execution policy configuration failed"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ PowerShell execution policy already configured"
            $installationResults.PowerShellExecutionPolicy = $true
        }
        
        # Step 3: Configure Windows features if needed
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Configuring Windows features" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        if (-not (Test-WindowsFeatures)) {
            Write-InstallationLog -Level Info -Message "Configuring Windows features..."
            $installationResults.WindowsFeatures = Install-WindowsFeatures
            
            if ($installationResults.WindowsFeatures) {
                Write-InstallationLog -Level Success -Message "✓ Windows features configured"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows features configuration completed with warnings"
            }
        }
        else {
            Write-InstallationLog -Level Info -Message "✓ Windows features already configured"
            $installationResults.WindowsFeatures = $true
        }
        
        # Step 4: Apply system configuration optimizations
        Write-Progress-Step -Step "Installing Prerequisites" -StepNumber 1 -TotalSteps 1 -Status "Optimizing system configuration" -SubStepNumber (++$currentStep) -TotalSubSteps $prerequisiteSteps
        
        Write-InstallationLog -Level Info -Message "Applying system configuration optimizations..."
        $installationResults.SystemConfiguration = Optimize-SystemConfiguration
        
        if ($installationResults.SystemConfiguration) {
            Write-InstallationLog -Level Success -Message "✓ System configuration optimized"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ System configuration optimization completed with warnings"
        }
        
        # Summary
        $successfulSteps = $installationResults.Values | Where-Object { $_ } | Measure-Object | Select-Object -ExpandProperty Count
        $totalSteps = $installationResults.Count
        
        Write-InstallationLog -Level Info -Message "Prerequisites installation summary: $successfulSteps/$totalSteps steps completed successfully"
        
        # Check if any critical prerequisites failed
        $criticalFailures = @()
        if (-not $installationResults.DotNetRuntime -and -not (Test-DotNetRuntime)) {
            $criticalFailures += ".NET Runtime"
        }
        
        if ($criticalFailures.Count -eq 0) {
            Write-InstallationLog -Level Success -Message "✓ All prerequisites installed and configured successfully"
            return $true
        }
        else {
            Write-InstallationLog -Level Error -Message "✗ Critical prerequisites failed: $($criticalFailures -join ', ')"
            Write-InstallationLog -Level Error -Message "Installation may fail or bridge may not function properly"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during prerequisites installation: $($_.Exception.Message)"
        return $false
    }
}

function Install-DotNetRuntime {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Downloading and installing .NET Runtime..."
    
    try {
        # Define .NET Runtime download URLs (latest stable versions)
        $dotNetRuntimes = @{
            "Framework" = @{
                Url = "https://download.microsoft.com/download/6/E/4/6E48E8AB-DC00-419E-9704-06DD46E5F81D/NDP472-KB4054530-x86-x64-AllOS-ENU.exe"
                FileName = "NDP472-KB4054530-x86-x64-AllOS-ENU.exe"
                Version = "4.7.2"
                Arguments = "/quiet /norestart"
            }
            "Core" = @{
                Url = "https://download.microsoft.com/download/1/7/2/172fab2a-6d0b-4b5d-9b8a-8e8b8b8b8b8b/windowsdesktop-runtime-6.0.25-win-x64.exe"
                FileName = "windowsdesktop-runtime-6.0.25-win-x64.exe"
                Version = "6.0"
                Arguments = "/quiet /norestart"
            }
        }
        
        # Try to install .NET Framework 4.7.2 first (most compatible)
        $frameworkRuntime = $dotNetRuntimes.Framework
        $downloadPath = Join-Path $env:TEMP $frameworkRuntime.FileName
        
        try {
            Write-InstallationLog -Level Info -Message "Downloading .NET Framework $($frameworkRuntime.Version)..."
            
            # Download with retry logic
            Invoke-WithRetry -OperationName ".NET Framework download" -MaxRetries 3 -ScriptBlock {
                $webClient = New-Object System.Net.WebClient
                try {
                    $webClient.Headers.Add('User-Agent', 'RepSet-Bridge-Installer/1.0')
                    $webClient.DownloadFile($frameworkRuntime.Url, $downloadPath)
                }
                finally {
                    $webClient.Dispose()
                }
            }
            
            if (Test-Path $downloadPath) {
                Write-InstallationLog -Level Info -Message "Installing .NET Framework $($frameworkRuntime.Version)..."
                
                # Run installer
                $process = Start-Process -FilePath $downloadPath -ArgumentList $frameworkRuntime.Arguments -Wait -PassThru -NoNewWindow
                
                if ($process.ExitCode -eq 0 -or $process.ExitCode -eq 3010) { # 3010 = reboot required
                    Write-InstallationLog -Level Success -Message ".NET Framework $($frameworkRuntime.Version) installed successfully"
                    
                    if ($process.ExitCode -eq 3010) {
                        Write-InstallationLog -Level Warning -Message "System reboot may be required for .NET Framework to function properly"
                    }
                    
                    # Clean up installer
                    Remove-Item $downloadPath -Force -ErrorAction SilentlyContinue
                    
                    # Verify installation
                    Start-Sleep -Seconds 2
                    if (Test-DotNetRuntime) {
                        return $true
                    }
                    else {
                        Write-InstallationLog -Level Warning -Message ".NET Framework installed but verification failed"
                        return $false
                    }
                }
                else {
                    Write-InstallationLog -Level Error -Message ".NET Framework installation failed with exit code: $($process.ExitCode)"
                    return $false
                }
            }
            else {
                Write-InstallationLog -Level Error -Message ".NET Framework download failed"
                return $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message ".NET Framework installation failed: $($_.Exception.Message)"
            
            # Clean up failed download
            if (Test-Path $downloadPath) {
                Remove-Item $downloadPath -Force -ErrorAction SilentlyContinue
            }
            
            # Fall back to manual instructions
            Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Please install .NET Framework 4.7.2 or later from:"
            Write-InstallationLog -Level Info -Message "https://dotnet.microsoft.com/download/dotnet-framework"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during .NET Runtime installation: $($_.Exception.Message)"
        Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Please install .NET Framework 4.7.2 or later manually"
        return $false
    }
}

function Set-PowerShellExecutionPolicy {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Configuring PowerShell execution policy..."
    
    try {
        # Try to set execution policy for current user first (doesn't require admin for this scope)
        try {
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force -ErrorAction Stop
            Write-InstallationLog -Level Success -Message "PowerShell execution policy set to RemoteSigned for current user"
            
            # Verify the change
            if (Test-PowerShellExecutionPolicy) {
                return $true
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set execution policy for current user: $($_.Exception.Message)"
        }
        
        # Try to set execution policy for local machine (requires admin)
        try {
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine -Force -ErrorAction Stop
            Write-InstallationLog -Level Success -Message "PowerShell execution policy set to RemoteSigned for local machine"
            
            # Verify the change
            if (Test-PowerShellExecutionPolicy) {
                return $true
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set execution policy for local machine: $($_.Exception.Message)"
        }
        
        # If both failed, provide manual instructions
        Write-InstallationLog -Level Warning -Message "Could not automatically configure PowerShell execution policy"
        Write-InstallationLog -Level Info -Message "MANUAL SOLUTION: Run the following command in an elevated PowerShell:"
        Write-InstallationLog -Level Info -Message "Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine"
        
        return $false
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error configuring PowerShell execution policy: $($_.Exception.Message)"
        return $false
    }
}

function Install-WindowsFeatures {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Configuring Windows features and services..."
    
    try {
        $configurationSuccess = $true
        
        # Ensure Windows Service Manager is running
        try {
            $serviceManager = Get-Service -Name "Spooler" -ErrorAction SilentlyContinue
            if ($serviceManager) {
                Write-InstallationLog -Level Success -Message "✓ Windows Service Manager is available"
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows Service Manager may not be available"
                $configurationSuccess = $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not verify Windows Service Manager"
            $configurationSuccess = $false
        }
        
        # Ensure Windows Event Log service is running
        try {
            $eventLogService = Get-Service -Name "EventLog" -ErrorAction SilentlyContinue
            if ($eventLogService) {
                if ($eventLogService.Status -ne 'Running') {
                    Write-InstallationLog -Level Info -Message "Starting Windows Event Log service..."
                    Start-Service -Name "EventLog" -ErrorAction Stop
                    Write-InstallationLog -Level Success -Message "✓ Windows Event Log service started"
                }
                else {
                    Write-InstallationLog -Level Success -Message "✓ Windows Event Log service is running"
                }
            }
            else {
                Write-InstallationLog -Level Warning -Message "⚠ Windows Event Log service not found"
                $configurationSuccess = $false
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "⚠ Could not configure Windows Event Log service: $($_.Exception.Message)"
            $configurationSuccess = $false
        }
        
        # Configure Windows Firewall (if needed)
        try {
            Write-InstallationLog -Level Info -Message "Checking Windows Firewall configuration..."
            
            # Check if Windows Firewall service is running
            $firewallService = Get-Service -Name "MpsSvc" -ErrorAction SilentlyContinue
            if ($firewallService -and $firewallService.Status -eq 'Running') {
                Write-InstallationLog -Level Info -Message "Windows Firewall is active - bridge may need firewall rules"
                Write-InstallationLog -Level Info -Message "Note: Firewall rules will be configured when the bridge service starts"
            }
            else {
                Write-InstallationLog -Level Info -Message "Windows Firewall service not running or not found"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check Windows Firewall: $($_.Exception.Message)"
        }
        
        if ($configurationSuccess) {
            Write-InstallationLog -Level Success -Message "✓ Windows features configured successfully"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ Windows features configuration completed with warnings"
        }
        
        return $configurationSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error configuring Windows features: $($_.Exception.Message)"
        return $false
    }
}

function Optimize-SystemConfiguration {
    [CmdletBinding()]
    param()
    
    Write-InstallationLog -Level Info -Message "Applying system configuration optimizations..."
    
    try {
        $optimizationSuccess = $true
        
        # Set high-resolution timer (improves service performance)
        try {
            Write-InstallationLog -Level Debug -Message "Configuring system timer resolution..."
            # This is a placeholder for timer configuration
            # In a real implementation, we might configure multimedia timer resolution
            Write-InstallationLog -Level Debug -Message "Timer configuration completed"
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Timer configuration failed: $($_.Exception.Message)"
        }
        
        # Configure service recovery options (will be applied when service is created)
        try {
            Write-InstallationLog -Level Debug -Message "Preparing service recovery configuration..."
            $script:ServiceRecoveryConfig = @{
                FirstFailure = "restart"
                SecondFailure = "restart"
                SubsequentFailures = "none"
                RestartDelay = 60000  # 1 minute in milliseconds
                ResetFailureCount = 86400  # 24 hours in seconds
            }
            Write-InstallationLog -Level Debug -Message "Service recovery configuration prepared"
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Service recovery configuration failed: $($_.Exception.Message)"
        }
        
        # Create installation registry entries for tracking
        try {
            Write-InstallationLog -Level Debug -Message "Creating installation registry entries..."
            
            $registryPath = "HKLM:\SOFTWARE\RepSet\Bridge"
            if (-not (Test-Path $registryPath)) {
                New-Item -Path $registryPath -Force | Out-Null
            }
            
            # Store installation metadata
            Set-ItemProperty -Path $registryPath -Name "InstallationId" -Value $script:InstallationId -Type String
            Set-ItemProperty -Path $registryPath -Name "InstallationDate" -Value (Get-Date -Format 'yyyy-MM-dd HH:mm:ss') -Type String
            Set-ItemProperty -Path $registryPath -Name "InstalledBy" -Value "automated-installer" -Type String
            Set-ItemProperty -Path $registryPath -Name "GymId" -Value $GymId -Type String
            Set-ItemProperty -Path $registryPath -Name "PlatformEndpoint" -Value $PlatformEndpoint -Type String
            
            Write-InstallationLog -Level Debug -Message "Installation registry entries created"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not create registry entries: $($_.Exception.Message)"
            $optimizationSuccess = $false
        }
        
        # Configure system environment for service
        try {
            Write-InstallationLog -Level Debug -Message "Configuring system environment..."
            
            # Ensure TEMP directory is accessible
            $tempDir = $env:TEMP
            if (Test-Path $tempDir) {
                Write-InstallationLog -Level Debug -Message "TEMP directory accessible: $tempDir"
            }
            else {
                Write-InstallationLog -Level Warning -Message "TEMP directory not accessible: $tempDir"
                $optimizationSuccess = $false
            }
            
            Write-InstallationLog -Level Debug -Message "System environment configuration completed"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "System environment configuration failed: $($_.Exception.Message)"
            $optimizationSuccess = $false
        }
        
        if ($optimizationSuccess) {
            Write-InstallationLog -Level Success -Message "✓ System configuration optimized successfully"
        }
        else {
            Write-InstallationLog -Level Warning -Message "⚠ System configuration optimization completed with warnings"
        }
        
        return $optimizationSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error during system configuration optimization: $($_.Exception.Message)"
        return $false
    }
}

# ================================================================
# Log Management and Cleanup Functions
# ================================================================

function Initialize-LoggingSystem {
    [CmdletBinding()]
    param()
    
    try {
        # Ensure log directory exists
        $logDir = Split-Path $script:LogFile -Parent
        if (-not (Test-Path $logDir)) {
            New-Item -Path $logDir -ItemType Directory -Force | Out-Null
        }
        
        # Clean up old installation logs (keep last 10)
        $oldLogs = Get-ChildItem -Path $logDir -Filter "RepSetBridge-Install-*.log" | 
                   Sort-Object LastWriteTime -Descending | 
                   Select-Object -Skip 10
        
        foreach ($oldLog in $oldLogs) {
            try {
                Remove-Item -Path $oldLog.FullName -Force -ErrorAction SilentlyContinue
                Write-InstallationLog -Level Debug -Message "Cleaned up old log file: $($oldLog.Name)"
            }
            catch {
                # Ignore cleanup failures
            }
        }
        
        # Initialize log file with header
        $logHeader = @"
# RepSet Bridge Installation Log
# Started: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
# Installation ID: $script:InstallationId
# Gym ID: $GymId
# Platform: $PlatformEndpoint
# PowerShell Version: $($PSVersionTable.PSVersion)
# OS Version: $([System.Environment]::OSVersion.VersionString)
# Machine: $([System.Environment]::MachineName)
# User: $([System.Environment]::UserName)
# ================================================================

"@
        
        Add-Content -Path $script:LogFile -Value $logHeader -ErrorAction SilentlyContinue
        
        Write-InstallationLog -Level Debug -Message "Logging system initialized successfully"
        return $true
    }
    catch {
        Write-Host "Warning: Could not initialize logging system: $($_.Exception.Message)" -ForegroundColor Yellow
        return $false
    }
}

function Get-InstallationLogSummary {
    [CmdletBinding()]
    param()
    
    try {
        if (-not (Test-Path $script:LogFile)) {
            return @{
                LogFile = $script:LogFile
                Exists = $false
                Size = 0
                Lines = 0
                Errors = 0
                Warnings = 0
            }
        }
        
        $logContent = Get-Content -Path $script:LogFile -ErrorAction SilentlyContinue
        $logFileInfo = Get-Item -Path $script:LogFile -ErrorAction SilentlyContinue
        
        $summary = @{
            LogFile = $script:LogFile
            Exists = $true
            Size = if ($logFileInfo) { $logFileInfo.Length } else { 0 }
            Lines = if ($logContent) { $logContent.Count } else { 0 }
            Errors = if ($logContent) { ($logContent | Where-Object { $_ -like "*[Error]*" }).Count } else { 0 }
            Warnings = if ($logContent) { ($logContent | Where-Object { $_ -like "*[Warning]*" }).Count } else { 0 }
            Created = if ($logFileInfo) { $logFileInfo.CreationTime } else { $null }
            LastModified = if ($logFileInfo) { $logFileInfo.LastWriteTime } else { $null }
        }
        
        return $summary
    }
    catch {
        return @{
            LogFile = $script:LogFile
            Exists = $false
            Error = $_.Exception.Message
        }
    }
}

function Export-InstallationDiagnostics {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$OutputPath = "$env:TEMP\RepSetBridge-Diagnostics-$(Get-Date -Format 'yyyyMMdd-HHmmss').zip"
    )
    
    Write-InstallationLog -Level Info -Message "Exporting installation diagnostics..."
    
    try {
        $tempDir = "$env:TEMP\RepSetBridge-Diagnostics-$script:InstallationId"
        
        # Create temporary directory for diagnostics
        if (Test-Path $tempDir) {
            Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
        }
        New-Item -Path $tempDir -ItemType Directory -Force | Out-Null
        
        # Copy installation log
        if (Test-Path $script:LogFile) {
            Copy-Item -Path $script:LogFile -Destination (Join-Path $tempDir "installation.log") -ErrorAction SilentlyContinue
        }
        
        # Copy structured log if it exists
        $structuredLogFile = $script:LogFile -replace '\.log$', '.json'
        if (Test-Path $structuredLogFile) {
            Copy-Item -Path $structuredLogFile -Destination (Join-Path $tempDir "installation.json") -ErrorAction SilentlyContinue
        }
        
        # Export system information
        $systemInfo = @{
            InstallationId = $script:InstallationId
            GymId = $GymId
            Timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
            OS = [System.Environment]::OSVersion.VersionString
            PowerShell = $PSVersionTable.PSVersion.ToString()
            Architecture = [System.Environment]::ProcessorArchitecture
            MachineName = [System.Environment]::MachineName
            UserName = [System.Environment]::UserName
            InstallPath = $InstallPath
            PlatformEndpoint = $PlatformEndpoint
        }
        
        $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath (Join-Path $tempDir "system-info.json") -Encoding UTF8
        
        # Export service information if service exists
        $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
        if ($service) {
            $serviceInfo = @{
                Name = $service.Name
                DisplayName = $service.DisplayName
                Status = $service.Status.ToString()
                StartType = $service.StartType.ToString()
                ServiceType = $service.ServiceType.ToString()
            }
            
            $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$($script:ServiceName)'" -ErrorAction SilentlyContinue
            if ($serviceDetails) {
                $serviceInfo.ProcessId = $serviceDetails.ProcessId
                $serviceInfo.PathName = $serviceDetails.PathName
                $serviceInfo.StartName = $serviceDetails.StartName
                $serviceInfo.State = $serviceDetails.State
            }
            
            $serviceInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath (Join-Path $tempDir "service-info.json") -Encoding UTF8
        }
        
        # Export recent Windows Event Log entries
        try {
            $recentEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; StartTime=(Get-Date).AddHours(-1)} -MaxEvents 50 -ErrorAction SilentlyContinue |
                           Where-Object { $_.Message -like "*RepSet*" -or $_.ProviderName -like "*RepSet*" }
            
            if ($recentEvents) {
                $eventData = $recentEvents | Select-Object TimeCreated, Id, LevelDisplayName, ProviderName, Message
                $eventData | ConvertTo-Json -Depth 3 | Out-File -FilePath (Join-Path $tempDir "events.json") -Encoding UTF8
            }
        }
        catch {
            # Ignore event log export failures
        }
        
        # Create ZIP file if possible
        try {
            if (Get-Command Compress-Archive -ErrorAction SilentlyContinue) {
                Compress-Archive -Path "$tempDir\*" -DestinationPath $OutputPath -Force
                Write-InstallationLog -Level Success -Message "Diagnostics exported to: $OutputPath"
                
                # Clean up temporary directory
                Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
                
                return $OutputPath
            }
            else {
                Write-InstallationLog -Level Warning -Message "Compress-Archive not available. Diagnostics available in: $tempDir"
                return $tempDir
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not create ZIP file: $($_.Exception.Message). Diagnostics available in: $tempDir"
            return $tempDir
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to export diagnostics: $($_.Exception.Message)"
        return $null
    }
}

# ================================================================
# Bridge Download and Verification Functions
# ================================================================

function Get-LatestBridge {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$Repository = $script:GitHubRepo,
        
        [Parameter(Mandatory=$false)]
        [string]$Architecture = "windows-amd64"
    )
    
    Write-InstallationLog -Level Info -Message "Fetching latest bridge release information from GitHub..."
    
    try {
        $apiUrl = "https://api.github.com/repos/$Repository/releases/latest"
        
        $releaseInfo = Invoke-WithRetry -OperationName "GitHub API request" -ScriptBlock {
            $headers = @{
                'User-Agent' = 'RepSet-Bridge-Installer/1.0'
                'Accept' = 'application/vnd.github.v3+json'
            }
            
            $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -TimeoutSec 30 -ErrorAction Stop
            return $response
        }
        
        if (-not $releaseInfo -or -not $releaseInfo.assets) {
            throw "No release information or assets found"
        }
        
        # Find the appropriate asset for Windows
        $windowsAssets = $releaseInfo.assets | Where-Object { 
            $_.name -like "*windows*" -or $_.name -like "*win*" -or $_.name -like "*.exe"
        }
        
        if (-not $windowsAssets) {
            throw "No Windows executable found in latest release"
        }
        
        # Prefer specific architecture, fallback to first Windows asset
        $selectedAsset = $windowsAssets | Where-Object { $_.name -like "*$Architecture*" } | Select-Object -First 1
        if (-not $selectedAsset) {
            $selectedAsset = $windowsAssets | Select-Object -First 1
        }
        
        # Look for checksum file
        $checksumAsset = $releaseInfo.assets | Where-Object { 
            $_.name -like "*checksum*" -or $_.name -like "*sha256*" -or $_.name -like "*.sha256"
        } | Select-Object -First 1
        
        $bridgeInfo = @{
            Version = $releaseInfo.tag_name
            ReleaseDate = $releaseInfo.published_at
            DownloadUrl = $selectedAsset.browser_download_url
            FileName = $selectedAsset.name
            FileSize = $selectedAsset.size
            ChecksumUrl = if ($checksumAsset) { $checksumAsset.browser_download_url } else { $null }
            ChecksumFileName = if ($checksumAsset) { $checksumAsset.name } else { $null }
        }
        
        Write-InstallationLog -Level Success -Message "Found bridge version $($bridgeInfo.Version) ($(([math]::Round($bridgeInfo.FileSize / 1MB, 2))) MB)"
        Write-InstallationLog -Level Debug -Message "Download URL: $($bridgeInfo.DownloadUrl)"
        
        return $bridgeInfo
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to get latest bridge release: $($_.Exception.Message)"
        throw
    }
}

function Get-BridgeExecutable {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$BridgeInfo,
        
        [Parameter(Mandatory=$false)]
        [string]$DownloadPath = $env:TEMP
    )
    
    $downloadFile = Join-Path $DownloadPath $BridgeInfo.FileName
    $checksumFile = if ($BridgeInfo.ChecksumUrl) { Join-Path $DownloadPath $BridgeInfo.ChecksumFileName } else { $null }
    
    try {
        Write-InstallationLog -Level Info -Message "Downloading bridge executable to: $downloadFile"
        
        # Download checksum file first if available
        if ($BridgeInfo.ChecksumUrl) {
            Write-InstallationLog -Level Debug -Message "Downloading checksum file..."
            Invoke-WithRetry -OperationName "Checksum download" -ScriptBlock {
                Invoke-WebRequest -Uri $BridgeInfo.ChecksumUrl -OutFile $checksumFile -TimeoutSec 60 -ErrorAction Stop
            }
        }
        
        # Download the bridge executable with progress reporting
        Invoke-WithRetry -OperationName "Bridge executable download" -MaxRetries 5 -ScriptBlock {
            $webClient = New-Object System.Net.WebClient
            
            try {
                # Register progress event handler
                Register-ObjectEvent -InputObject $webClient -EventName DownloadProgressChanged -Action {
                    $percent = $Event.SourceEventArgs.ProgressPercentage
                    $received = $Event.SourceEventArgs.BytesReceived
                    $total = $Event.SourceEventArgs.TotalBytesToReceive
                    
                    if ($total -gt 0) {
                        $receivedMB = [math]::Round($received / 1MB, 2)
                        $totalMB = [math]::Round($total / 1MB, 2)
                        Write-Progress -Activity "Downloading RepSet Bridge" -Status "Downloaded $receivedMB MB of $totalMB MB" -PercentComplete $percent
                    }
                } | Out-Null
                
                # Set timeout and user agent
                $webClient.Headers.Add('User-Agent', 'RepSet-Bridge-Installer/1.0')
                
                # Download the file
                $webClient.DownloadFile($BridgeInfo.DownloadUrl, $downloadFile)
                
                Write-Progress -Activity "Downloading RepSet Bridge" -Completed
                Write-InstallationLog -Level Success -Message "Bridge executable downloaded successfully"
            }
            finally {
                # Clean up event handlers and dispose webclient
                Get-EventSubscriber | Where-Object { $_.SourceObject -eq $webClient } | Unregister-Event
                $webClient.Dispose()
            }
        }
        
        # Verify file was downloaded and has correct size
        if (-not (Test-Path $downloadFile)) {
            throw "Downloaded file not found: $downloadFile"
        }
        
        $actualSize = (Get-Item $downloadFile).Length
        if ($actualSize -ne $BridgeInfo.FileSize) {
            throw "Downloaded file size mismatch. Expected: $($BridgeInfo.FileSize), Actual: $actualSize"
        }
        
        Write-InstallationLog -Level Success -Message "File size verification passed"
        
        # Verify file integrity using SHA-256
        if ($checksumFile -and (Test-Path $checksumFile)) {
            Test-FileIntegrity -FilePath $downloadFile -ChecksumFile $checksumFile
        }
        else {
            Write-InstallationLog -Level Warning -Message "No checksum file available for integrity verification"
            
            # Perform basic file validation
            if ($downloadFile -like "*.exe") {
                Test-ExecutableFile -FilePath $downloadFile
            }
        }
        
        return $downloadFile
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to download bridge executable: $($_.Exception.Message)"
        
        # Clean up partial downloads
        if (Test-Path $downloadFile) {
            Remove-Item $downloadFile -Force -ErrorAction SilentlyContinue
        }
        if ($checksumFile -and (Test-Path $checksumFile)) {
            Remove-Item $checksumFile -Force -ErrorAction SilentlyContinue
        }
        
        throw
    }
}

function Test-FileIntegrity {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$true)]
        [string]$ChecksumFile
    )
    
    Write-InstallationLog -Level Info -Message "Verifying file integrity using SHA-256..."
    
    try {
        # Calculate SHA-256 hash of downloaded file
        $actualHash = Get-FileHash -Path $FilePath -Algorithm SHA256 -ErrorAction Stop
        $actualHashValue = $actualHash.Hash.ToLower()
        
        Write-InstallationLog -Level Debug -Message "Calculated SHA-256: $actualHashValue"
        
        # Read expected hash from checksum file
        $checksumContent = Get-Content $ChecksumFile -ErrorAction Stop
        $expectedHashValue = $null
        
        # Parse different checksum file formats
        foreach ($line in $checksumContent) {
            $line = $line.Trim()
            if ([string]::IsNullOrWhiteSpace($line) -or $line.StartsWith('#')) {
                continue
            }
            
            # Format: hash filename
            if ($line -match '^([a-fA-F0-9]{64})\s+(.+)$') {
                $hashFromFile = $matches[1].ToLower()
                $fileFromChecksum = $matches[2]
                
                # Check if this line corresponds to our file
                if ($fileFromChecksum -eq (Split-Path $FilePath -Leaf) -or $fileFromChecksum -like "*$(Split-Path $FilePath -Leaf)*") {
                    $expectedHashValue = $hashFromFile
                    break
                }
            }
            # Format: hash only (single file)
            elseif ($line -match '^[a-fA-F0-9]{64}$') {
                $expectedHashValue = $line.ToLower()
                break
            }
        }
        
        if (-not $expectedHashValue) {
            throw "Could not find expected hash for file in checksum file"
        }
        
        Write-InstallationLog -Level Debug -Message "Expected SHA-256: $expectedHashValue"
        
        # Compare hashes
        if ($actualHashValue -eq $expectedHashValue) {
            Write-InstallationLog -Level Success -Message "File integrity verification passed - SHA-256 hash matches"
        }
        else {
            throw "File integrity verification failed - SHA-256 hash mismatch. Expected: $expectedHashValue, Actual: $actualHashValue"
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "File integrity verification failed: $($_.Exception.Message)"
        throw
    }
}

function Test-ExecutableFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$FilePath
    )
    
    Write-InstallationLog -Level Info -Message "Performing basic executable file validation..."
    
    try {
        # Check if file is a valid PE executable
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        
        if ($fileBytes.Length -lt 64) {
            throw "File too small to be a valid executable"
        }
        
        # Check DOS header signature (MZ)
        if ($fileBytes[0] -ne 0x4D -or $fileBytes[1] -ne 0x5A) {
            throw "Invalid DOS header signature"
        }
        
        # Get PE header offset
        $peOffset = [BitConverter]::ToInt32($fileBytes, 60)
        
        if ($peOffset -ge $fileBytes.Length - 4) {
            throw "Invalid PE header offset"
        }
        
        # Check PE signature
        if ($fileBytes[$peOffset] -ne 0x50 -or $fileBytes[$peOffset + 1] -ne 0x45 -or 
            $fileBytes[$peOffset + 2] -ne 0x00 -or $fileBytes[$peOffset + 3] -ne 0x00) {
            throw "Invalid PE signature"
        }
        
        Write-InstallationLog -Level Success -Message "Basic executable file validation passed"
        
        # Additional check: try to get file version info
        try {
            $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($FilePath)
            if ($versionInfo.FileDescription -or $versionInfo.ProductName) {
                Write-InstallationLog -Level Info -Message "Executable info: $($versionInfo.FileDescription) $($versionInfo.FileVersion)"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not read version info: $($_.Exception.Message)"
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Executable file validation failed: $($_.Exception.Message)"
        throw
    }
}

# ================================================================
# Bridge Installation and Configuration Manager Functions
# ================================================================

function New-InstallationDirectory {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$InstallPath
    )
    
    Write-InstallationLog -Level Info -Message "Creating installation directory structure..."
    
    try {
        # Create main installation directory
        if (-not (Test-Path $InstallPath)) {
            New-Item -Path $InstallPath -ItemType Directory -Force | Out-Null
            Write-InstallationLog -Level Success -Message "Created installation directory: $InstallPath"
        }
        else {
            Write-InstallationLog -Level Info -Message "Installation directory already exists: $InstallPath"
        }
        
        # Create subdirectories for organized installation
        $subDirectories = @(
            "logs",
            "config",
            "data",
            "temp"
        )
        
        foreach ($subDir in $subDirectories) {
            $subDirPath = Join-Path $InstallPath $subDir
            if (-not (Test-Path $subDirPath)) {
                New-Item -Path $subDirPath -ItemType Directory -Force | Out-Null
                Write-InstallationLog -Level Debug -Message "Created subdirectory: $subDirPath"
            }
        }
        
        # Set appropriate permissions on the installation directory
        try {
            $acl = Get-Acl $InstallPath
            
            # Grant full control to SYSTEM and Administrators
            $systemSid = New-Object System.Security.Principal.SecurityIdentifier("S-1-5-18")
            $adminsSid = New-Object System.Security.Principal.SecurityIdentifier("S-1-5-32-544")
            
            $systemAccess = New-Object System.Security.AccessControl.FileSystemAccessRule(
                $systemSid, "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow"
            )
            $adminsAccess = New-Object System.Security.AccessControl.FileSystemAccessRule(
                $adminsSid, "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow"
            )
            
            $acl.SetAccessRule($systemAccess)
            $acl.SetAccessRule($adminsAccess)
            Set-Acl -Path $InstallPath -AclObject $acl
            
            Write-InstallationLog -Level Debug -Message "Set security permissions on installation directory"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set security permissions: $($_.Exception.Message)"
        }
        
        Write-InstallationLog -Level Success -Message "Installation directory structure created successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to create installation directory structure: $($_.Exception.Message)"
        throw
    }
}

function Install-BridgeExecutable {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ExecutablePath,
        
        [Parameter(Mandatory=$true)]
        [string]$InstallPath
    )
    
    Write-InstallationLog -Level Info -Message "Installing RepSet Bridge executable..."
    
    try {
        # Validate source executable exists
        if (-not (Test-Path $ExecutablePath)) {
            throw "Source executable not found: $ExecutablePath"
        }
        
        # Create installation directory structure
        New-InstallationDirectory -InstallPath $InstallPath
        
        # Determine target executable name and path
        $executableName = "repset-bridge.exe"
        $targetExecutable = Join-Path $InstallPath $executableName
        
        # Check if target already exists and handle accordingly
        if (Test-Path $targetExecutable) {
            Write-InstallationLog -Level Warning -Message "Existing bridge executable found, creating backup..."
            
            $backupPath = "$targetExecutable.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
            try {
                Copy-Item -Path $targetExecutable -Destination $backupPath -Force
                Write-InstallationLog -Level Info -Message "Created backup: $backupPath"
            }
            catch {
                Write-InstallationLog -Level Warning -Message "Could not create backup: $($_.Exception.Message)"
            }
        }
        
        # Copy executable to installation directory
        Write-InstallationLog -Level Info -Message "Copying executable from $ExecutablePath to $targetExecutable"
        
        Invoke-WithRetry -OperationName "Executable installation" -ScriptBlock {
            Copy-Item -Path $ExecutablePath -Destination $targetExecutable -Force -ErrorAction Stop
        }
        
        # Verify the copied executable
        if (-not (Test-Path $targetExecutable)) {
            throw "Failed to copy executable to target location"
        }
        
        $sourceSize = (Get-Item $ExecutablePath).Length
        $targetSize = (Get-Item $targetExecutable).Length
        
        if ($sourceSize -ne $targetSize) {
            throw "File size mismatch after copy. Source: $sourceSize, Target: $targetSize"
        }
        
        # Verify executable can be run (basic test)
        try {
            Write-InstallationLog -Level Debug -Message "Testing executable functionality..."
            $testResult = & $targetExecutable --version 2>&1
            if ($LASTEXITCODE -eq 0) {
                Write-InstallationLog -Level Success -Message "Executable test successful: $testResult"
            }
            else {
                Write-InstallationLog -Level Warning -Message "Executable test returned non-zero exit code: $LASTEXITCODE"
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not test executable: $($_.Exception.Message)"
        }
        
        # Set executable permissions and attributes
        try {
            # Remove read-only attribute if present
            $attributes = (Get-Item $targetExecutable).Attributes
            if ($attributes -band [System.IO.FileAttributes]::ReadOnly) {
                $attributes = $attributes -bxor [System.IO.FileAttributes]::ReadOnly
                Set-ItemProperty -Path $targetExecutable -Name Attributes -Value $attributes
            }
            
            Write-InstallationLog -Level Debug -Message "Set executable attributes"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set executable attributes: $($_.Exception.Message)"
        }
        
        # Clean up temporary download file
        if ($ExecutablePath -like "$env:TEMP\*") {
            try {
                Remove-Item -Path $ExecutablePath -Force -ErrorAction SilentlyContinue
                Write-InstallationLog -Level Debug -Message "Cleaned up temporary download file"
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Could not clean up temporary file: $($_.Exception.Message)"
            }
        }
        
        Write-InstallationLog -Level Success -Message "RepSet Bridge executable installed successfully to: $targetExecutable"
        return $targetExecutable
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to install bridge executable: $($_.Exception.Message)"
        throw
    }
}

function New-BridgeConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$InstallPath,
        
        [Parameter(Mandatory=$true)]
        [string]$PairCode,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId,
        
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint
    )
    
    Write-InstallationLog -Level Info -Message "Creating RepSet Bridge configuration..."
    
    try {
        # Determine configuration file path
        $configDir = Join-Path $InstallPath "config"
        $configFile = Join-Path $configDir $script:ConfigFileName
        
        # Ensure config directory exists
        if (-not (Test-Path $configDir)) {
            New-Item -Path $configDir -ItemType Directory -Force | Out-Null
        }
        
        # Generate unique device ID
        $deviceId = "gym-$GymId-$(Get-Date -Format 'yyyyMMddHHmmss')"
        
        # Create configuration content
        $configContent = @"
# RepSet Bridge Configuration
# Auto-generated during installation on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
# Installation ID: $script:InstallationId

# Device identification
device_id: "$deviceId"
device_key: "$PairCode"
server_url: "$PlatformEndpoint"
tier: "normal"

# Service configuration
service:
  auto_start: true
  restart_on_failure: true
  failure_actions: ["restart", "restart", "none"]
  restart_delay: 60000  # milliseconds
  log_level: "info"

# Installation metadata
installation:
  version: "automated-installer"
  installed_at: "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
  installed_by: "automated-installer"
  pair_code: "$PairCode"
  gym_id: "$GymId"
  installation_id: "$script:InstallationId"

# Logging configuration
logging:
  level: "info"
  file: "logs/bridge.log"
  max_size: "10MB"
  max_files: 5
  console: false

# Network configuration
network:
  timeout: 30
  retry_attempts: 3
  retry_delay: 5
  keep_alive: true

# Security settings
security:
  verify_ssl: true
  auto_update: true
  telemetry: true
"@

        # Backup existing configuration if it exists
        if (Test-Path $configFile) {
            $backupFile = "$configFile.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
            try {
                Copy-Item -Path $configFile -Destination $backupFile -Force
                Write-InstallationLog -Level Info -Message "Created configuration backup: $backupFile"
            }
            catch {
                Write-InstallationLog -Level Warning -Message "Could not create configuration backup: $($_.Exception.Message)"
            }
        }
        
        # Write configuration file
        Write-InstallationLog -Level Info -Message "Writing configuration to: $configFile"
        
        Invoke-WithRetry -OperationName "Configuration file creation" -ScriptBlock {
            $configContent | Out-File -FilePath $configFile -Encoding UTF8 -Force -ErrorAction Stop
        }
        
        # Verify configuration file was created
        if (-not (Test-Path $configFile)) {
            throw "Configuration file was not created successfully"
        }
        
        # Validate configuration file content
        Test-BridgeConfiguration -ConfigFile $configFile
        
        # Set appropriate permissions on configuration file
        try {
            $acl = Get-Acl $configFile
            
            # Remove inheritance and set explicit permissions
            $acl.SetAccessRuleProtection($true, $false)
            
            # Grant full control to SYSTEM and Administrators only
            $systemSid = New-Object System.Security.Principal.SecurityIdentifier("S-1-5-18")
            $adminsSid = New-Object System.Security.Principal.SecurityIdentifier("S-1-5-32-544")
            
            $systemAccess = New-Object System.Security.AccessControl.FileSystemAccessRule(
                $systemSid, "FullControl", "Allow"
            )
            $adminsAccess = New-Object System.Security.AccessControl.FileSystemAccessRule(
                $adminsSid, "FullControl", "Allow"
            )
            
            $acl.SetAccessRule($systemAccess)
            $acl.SetAccessRule($adminsAccess)
            Set-Acl -Path $configFile -AclObject $acl
            
            Write-InstallationLog -Level Debug -Message "Set secure permissions on configuration file"
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not set configuration file permissions: $($_.Exception.Message)"
        }
        
        Write-InstallationLog -Level Success -Message "RepSet Bridge configuration created successfully"
        Write-InstallationLog -Level Info -Message "Device ID: $deviceId"
        Write-InstallationLog -Level Info -Message "Configuration file: $configFile"
        
        return $configFile
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to create bridge configuration: $($_.Exception.Message)"
        throw
    }
}

function Test-BridgeConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ConfigFile
    )
    
    Write-InstallationLog -Level Debug -Message "Validating bridge configuration file..."
    
    try {
        # Check if file exists and is readable
        if (-not (Test-Path $ConfigFile)) {
            throw "Configuration file not found: $ConfigFile"
        }
        
        # Read configuration content
        $configContent = Get-Content -Path $ConfigFile -Raw -ErrorAction Stop
        
        if ([string]::IsNullOrWhiteSpace($configContent)) {
            throw "Configuration file is empty"
        }
        
        # Basic YAML structure validation
        $requiredFields = @(
            'device_id:',
            'device_key:',
            'server_url:',
            'tier:'
        )
        
        foreach ($field in $requiredFields) {
            if ($configContent -notlike "*$field*") {
                throw "Required configuration field missing: $field"
            }
        }
        
        # Validate specific field formats
        if ($configContent -match 'device_id:\s*"([^"]+)"') {
            $deviceId = $matches[1]
            if ([string]::IsNullOrWhiteSpace($deviceId) -or $deviceId.Length -lt 5) {
                throw "Invalid device_id format"
            }
        }
        else {
            throw "device_id field not found or malformed"
        }
        
        if ($configContent -match 'device_key:\s*"([^"]+)"') {
            $deviceKey = $matches[1]
            if ([string]::IsNullOrWhiteSpace($deviceKey) -or $deviceKey.Length -lt 8) {
                throw "Invalid device_key format"
            }
        }
        else {
            throw "device_key field not found or malformed"
        }
        
        if ($configContent -match 'server_url:\s*"([^"]+)"') {
            $serverUrl = $matches[1]
            if (-not ($serverUrl -like "http*://*")) {
                throw "Invalid server_url format - must be a valid HTTP/HTTPS URL"
            }
        }
        else {
            throw "server_url field not found or malformed"
        }
        
        # Check file size (should be reasonable for a config file)
        $fileSize = (Get-Item $ConfigFile).Length
        if ($fileSize -lt 100 -or $fileSize -gt 10KB) {
            Write-InstallationLog -Level Warning -Message "Configuration file size seems unusual: $fileSize bytes"
        }
        
        # Verify file encoding (should be UTF-8)
        $encoding = Get-FileEncoding -Path $ConfigFile
        if ($encoding -ne "UTF8") {
            Write-InstallationLog -Level Warning -Message "Configuration file encoding is not UTF-8: $encoding"
        }
        
        Write-InstallationLog -Level Success -Message "Configuration file validation passed"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Configuration validation failed: $($_.Exception.Message)"
        throw
    }
}

function Get-FileEncoding {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    try {
        $bytes = Get-Content -Path $Path -Encoding Byte -ReadCount 4 -TotalCount 4
        
        if ($bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
            return "UTF8"
        }
        elseif ($bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {
            return "Unicode"
        }
        elseif ($bytes[0] -eq 0xFE -and $bytes[1] -eq 0xFF) {
            return "BigEndianUnicode"
        }
        elseif ($bytes[0] -eq 0x00 -and $bytes[1] -eq 0x00 -and $bytes[2] -eq 0xFE -and $bytes[3] -eq 0xFF) {
            return "UTF32"
        }
        else {
            return "ASCII"
        }
    }
    catch {
        return "Unknown"
    }
}

# ================================================================
# Windows Service Management Functions
# ================================================================

function Install-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$InstallPath,
        
        [Parameter(Mandatory=$true)]
        [string]$ExecutablePath,
        
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName,
        
        [Parameter(Mandatory=$false)]
        [string]$DisplayName = $script:ServiceDisplayName,
        
        [Parameter(Mandatory=$false)]
        [string]$Description = $script:ServiceDescription,
        
        [Parameter(Mandatory=$false)]
        [switch]$UpgradeMode
    )
    
    Write-InstallationLog -Level Info -Message "Installing RepSet Bridge Windows service..."
    
    try {
        # Validate executable exists
        if (-not (Test-Path $ExecutablePath)) {
            throw "Bridge executable not found: $ExecutablePath"
        }
        
        # Check if service already exists
        $existingService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        $isUpgrade = $false
        
        if ($existingService) {
            $isUpgrade = $true
            Write-InstallationLog -Level Warning -Message "Service '$ServiceName' already exists. Handling upgrade scenario..."
            
            # Get current service configuration for preservation
            $currentConfig = Get-ServiceConfiguration -ServiceName $ServiceName
            Write-InstallationLog -Level Info -Message "Current service configuration preserved for upgrade"
            
            # Handle upgrade scenario with enhanced error handling
            $upgradeResult = Update-BridgeService -ServiceName $ServiceName -ExecutablePath $ExecutablePath -CurrentConfig $currentConfig
            if (-not $upgradeResult) {
                throw "Service upgrade failed"
            }
            
            Write-InstallationLog -Level Success -Message "Service upgrade completed successfully"
            return $true
        }
        
        # Prepare service installation parameters
        $configFile = Join-Path $InstallPath "config\$script:ConfigFileName"
        $logDir = Join-Path $InstallPath "logs"
        
        # Ensure log directory exists
        if (-not (Test-Path $logDir)) {
            New-Item -Path $logDir -ItemType Directory -Force | Out-Null
        }
        
        # Build service command line arguments
        $serviceArgs = @(
            "--config `"$configFile`""
            "--log-dir `"$logDir`""
            "--service"
        )
        $serviceCommand = "`"$ExecutablePath`" $($serviceArgs -join ' ')"
        
        Write-InstallationLog -Level Debug -Message "Service command: $serviceCommand"
        
        # Install the service using sc.exe for maximum compatibility
        Write-InstallationLog -Level Info -Message "Creating Windows service registration..."
        
        $scCreateArgs = @(
            'create'
            $ServiceName
            "binPath= $serviceCommand"
            "DisplayName= $DisplayName"
            'start= auto'
            'type= own'
            'error= normal'
        )
        
        & sc.exe @scCreateArgs | Out-Null
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to create service (sc.exe exit code: $LASTEXITCODE)"
        }
        
        Write-InstallationLog -Level Success -Message "Service created successfully"
        
        # Set service description
        & sc.exe description $ServiceName $Description | Out-Null
        if ($LASTEXITCODE -ne 0) {
            Write-InstallationLog -Level Warning -Message "Failed to set service description (exit code: $LASTEXITCODE)"
        }
        
        # Configure service failure recovery actions
        Write-InstallationLog -Level Info -Message "Configuring service failure recovery settings..."
        
        # Set failure actions: restart after 1 minute, restart after 2 minutes, then no action
        $failureActions = "reset= 86400 actions= restart/60000/restart/120000/none/0"
        & sc.exe failure $ServiceName $failureActions | Out-Null
        if ($LASTEXITCODE -ne 0) {
            Write-InstallationLog -Level Warning -Message "Failed to set service failure actions (exit code: $LASTEXITCODE)"
        }
        
        # Set service to restart on failure
        & sc.exe failureflag $ServiceName 1 | Out-Null
        if ($LASTEXITCODE -ne 0) {
            Write-InstallationLog -Level Warning -Message "Failed to set service failure flag (exit code: $LASTEXITCODE)"
        }
        
        # Configure service to run as Local System (most compatible for hardware access)
        & sc.exe config $ServiceName obj= LocalSystem | Out-Null
        if ($LASTEXITCODE -ne 0) {
            Write-InstallationLog -Level Warning -Message "Failed to set service account (exit code: $LASTEXITCODE)"
        }
        
        # Set service dependencies (if any)
        # The bridge typically needs network services to be available
        & sc.exe config $ServiceName depend= "Tcpip/Dhcp" | Out-Null
        if ($LASTEXITCODE -ne 0) {
            Write-InstallationLog -Level Warning -Message "Failed to set service dependencies (exit code: $LASTEXITCODE)"
        }
        
        # Verify service was created successfully
        $newService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $newService) {
            throw "Service was not created successfully - not found in service list"
        }
        
        # Get detailed service information for verification
        $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
        if ($serviceDetails) {
            Write-InstallationLog -Level Info -Message "Service Details:"
            Write-InstallationLog -Level Info -Message "  Name: $($serviceDetails.Name)"
            Write-InstallationLog -Level Info -Message "  Display Name: $($serviceDetails.DisplayName)"
            Write-InstallationLog -Level Info -Message "  Path: $($serviceDetails.PathName)"
            Write-InstallationLog -Level Info -Message "  Start Mode: $($serviceDetails.StartMode)"
            Write-InstallationLog -Level Info -Message "  Service Account: $($serviceDetails.StartName)"
            Write-InstallationLog -Level Info -Message "  State: $($serviceDetails.State)"
        }
        
        Write-InstallationLog -Level Success -Message "RepSet Bridge service installed successfully"
        Write-InstallationLog -Level Info -Message "Service Name: $ServiceName"
        Write-InstallationLog -Level Info -Message "Display Name: $DisplayName"
        Write-InstallationLog -Level Info -Message "Executable: $ExecutablePath"
        
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to install bridge service: $($_.Exception.Message)"
        
        # Attempt cleanup if service creation partially succeeded
        try {
            $cleanupService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            if ($cleanupService) {
                Write-InstallationLog -Level Info -Message "Cleaning up partially created service..."
                & sc.exe delete $ServiceName | Out-Null
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not clean up partially created service: $($_.Exception.Message)"
        }
        
        throw
    }
}

function Start-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 60,
        
        [Parameter(Mandatory=$false)]
        [switch]$ValidateAutoStart
    )
    
    Write-InstallationLog -Level Info -Message "Starting RepSet Bridge service..."
    
    try {
        # Verify service exists
        $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $service) {
            throw "Service '$ServiceName' not found. Please install the service first."
        }
        
        # Validate auto-start configuration if requested
        if ($ValidateAutoStart) {
            $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
            if ($serviceDetails -and $serviceDetails.StartMode -ne 'Auto') {
                Write-InstallationLog -Level Warning -Message "Service is not configured for automatic startup. Current mode: $($serviceDetails.StartMode)"
                Write-InstallationLog -Level Info -Message "Configuring service for automatic startup..."
                
                & sc.exe config $ServiceName start= auto | Out-Null
                if ($LASTEXITCODE -eq 0) {
                    Write-InstallationLog -Level Success -Message "Service configured for automatic startup"
                }
                else {
                    Write-InstallationLog -Level Warning -Message "Failed to configure automatic startup (exit code: $LASTEXITCODE)"
                }
            }
            else {
                Write-InstallationLog -Level Info -Message "Service is properly configured for automatic startup"
            }
        }
        
        # Check current service status
        Write-InstallationLog -Level Debug -Message "Current service status: $($service.Status)"
        
        if ($service.Status -eq 'Running') {
            Write-InstallationLog -Level Info -Message "Service is already running"
            $verificationResult = Test-BridgeServiceStatus -ServiceName $ServiceName
            
            # Additional health check for already running service
            if ($verificationResult) {
                Test-ServiceHealthAfterStart -ServiceName $ServiceName
            }
            
            return $verificationResult
        }
        
        if ($service.Status -eq 'StartPending') {
            Write-InstallationLog -Level Info -Message "Service is already starting, waiting for completion..."
        }
        else {
            # Validate service configuration before starting
            $preStartValidation = Test-ServicePreStartConditions -ServiceName $ServiceName
            if (-not $preStartValidation) {
                Write-InstallationLog -Level Warning -Message "Pre-start validation failed, but attempting to start anyway..."
            }
            
            # Start the service
            Write-InstallationLog -Level Info -Message "Starting service '$ServiceName'..."
            Start-Service -Name $ServiceName -ErrorAction Stop
        }
        
        # Wait for service to start and verify it's running properly
        Write-InstallationLog -Level Info -Message "Waiting for service to start (timeout: $TimeoutSeconds seconds)..."
        
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        $serviceStarted = $false
        $lastStatus = ""
        
        do {
            Start-Sleep -Seconds 2
            $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            
            if ($service.Status -eq 'Running') {
                $serviceStarted = $true
                break
            }
            elseif ($service.Status -eq 'Stopped') {
                # Service stopped unexpectedly, check event logs for details
                Write-InstallationLog -Level Warning -Message "Service stopped unexpectedly during startup"
                break
            }
            
            # Log status changes
            if ($service.Status -ne $lastStatus) {
                Write-InstallationLog -Level Debug -Message "Service status changed: $lastStatus -> $($service.Status)"
                $lastStatus = $service.Status
            }
            
            Write-InstallationLog -Level Debug -Message "Service status: $($service.Status), elapsed: $([math]::Round($stopwatch.Elapsed.TotalSeconds, 1))s"
            
        } while ($stopwatch.Elapsed.TotalSeconds -lt $TimeoutSeconds)
        
        $stopwatch.Stop()
        
        if (-not $serviceStarted) {
            # Get more detailed error information
            $errorDetails = Get-ServiceStartupError -ServiceName $ServiceName
            throw "Service failed to start within $TimeoutSeconds seconds. Status: $($service.Status). $errorDetails"
        }
        
        Write-InstallationLog -Level Success -Message "Service started successfully in $([math]::Round($stopwatch.Elapsed.TotalSeconds, 1)) seconds"
        
        # Perform comprehensive post-startup verification
        $serviceStatus = Test-BridgeServiceStatus -ServiceName $ServiceName
        if ($serviceStatus) {
            # Additional health checks after successful startup
            Test-ServiceHealthAfterStart -ServiceName $ServiceName
            Write-InstallationLog -Level Success -Message "Service startup verification completed successfully"
            return $true
        }
        else {
            Write-InstallationLog -Level Warning -Message "Service started but verification checks failed"
            return $false
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to start bridge service: $($_.Exception.Message)"
        
        # Enhanced error diagnostics
        try {
            # Check recent service events
            $recentEvents = Get-WinEvent -FilterHashtable @{LogName='System'; ID=7034,7031,7030,7009,7000,7001,7023,7024; StartTime=(Get-Date).AddMinutes(-5)} -MaxEvents 10 -ErrorAction SilentlyContinue
            if ($recentEvents) {
                Write-InstallationLog -Level Info -Message "Recent service-related events:"
                foreach ($event in $recentEvents) {
                    if ($event.Message -like "*$ServiceName*") {
                        Write-InstallationLog -Level Info -Message "  $($event.TimeCreated): Event ID $($event.Id) - $($event.Message)"
                    }
                }
            }
            
            # Check application event log for bridge-specific errors
            $appEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; StartTime=(Get-Date).AddMinutes(-5)} -MaxEvents 5 -ErrorAction SilentlyContinue
            if ($appEvents) {
                $bridgeEvents = $appEvents | Where-Object { $_.Message -like "*RepSet*" -or $_.Message -like "*Bridge*" }
                if ($bridgeEvents) {
                    Write-InstallationLog -Level Info -Message "Recent bridge application events:"
                    foreach ($event in $bridgeEvents) {
                        Write-InstallationLog -Level Info -Message "  $($event.TimeCreated): $($event.Message)"
                    }
                }
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not retrieve service events: $($_.Exception.Message)"
        }
        
        throw
    }
}

function Test-ServicePreStartConditions {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName
    )
    
    Write-InstallationLog -Level Debug -Message "Validating service pre-start conditions..."
    
    try {
        $allConditionsMet = $true
        
        # Get service details
        $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
        if (-not $serviceDetails) {
            Write-InstallationLog -Level Error -Message "Service details not found"
            return $false
        }
        
        # Check if executable exists and is accessible
        $binaryPath = $serviceDetails.PathName
        if ($binaryPath -match '^"([^"]+)"') {
            $executablePath = $matches[1]
        }
        else {
            $executablePath = $binaryPath.Split(' ')[0]
        }
        
        if (-not (Test-Path $executablePath)) {
            Write-InstallationLog -Level Error -Message "Service executable not found: $executablePath"
            $allConditionsMet = $false
        }
        else {
            Write-InstallationLog -Level Debug -Message "Service executable verified: $executablePath"
        }
        
        # Check if config file exists (if specified in command line)
        if ($binaryPath -match '--config\s+"([^"]+)"') {
            $configPath = $matches[1]
            if (-not (Test-Path $configPath)) {
                Write-InstallationLog -Level Warning -Message "Configuration file not found: $configPath"
                $allConditionsMet = $false
            }
            else {
                Write-InstallationLog -Level Debug -Message "Configuration file verified: $configPath"
            }
        }
        
        # Check service dependencies
        if ($serviceDetails.ServicesDependedOn) {
            foreach ($dependency in $serviceDetails.ServicesDependedOn) {
                $depService = Get-Service -Name $dependency -ErrorAction SilentlyContinue
                if (-not $depService -or $depService.Status -ne 'Running') {
                    Write-InstallationLog -Level Warning -Message "Service dependency not running: $dependency"
                    # Don't fail for dependencies, just warn
                }
                else {
                    Write-InstallationLog -Level Debug -Message "Service dependency verified: $dependency"
                }
            }
        }
        
        return $allConditionsMet
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Pre-start condition validation failed: $($_.Exception.Message)"
        return $false
    }
}

function Test-ServiceHealthAfterStart {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName
    )
    
    Write-InstallationLog -Level Debug -Message "Performing post-startup health checks..."
    
    try {
        # Wait a moment for service to fully initialize
        Start-Sleep -Seconds 3
        
        # Get service process information
        $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
        if ($serviceDetails -and $serviceDetails.ProcessId -gt 0) {
            $process = Get-Process -Id $serviceDetails.ProcessId -ErrorAction SilentlyContinue
            if ($process) {
                Write-InstallationLog -Level Info -Message "Service Health Check:"
                Write-InstallationLog -Level Info -Message "  Process ID: $($process.Id)"
                Write-InstallationLog -Level Info -Message "  Memory Usage: $([math]::Round($process.WorkingSet / 1MB, 2)) MB"
                Write-InstallationLog -Level Info -Message "  CPU Time: $($process.TotalProcessorTime.TotalSeconds) seconds"
                Write-InstallationLog -Level Info -Message "  Start Time: $($process.StartTime)"
                
                # Check if process is responsive (not hung)
                if (-not $process.Responding) {
                    Write-InstallationLog -Level Warning -Message "Service process appears to be unresponsive"
                }
                else {
                    Write-InstallationLog -Level Success -Message "Service process is responsive"
                }
            }
        }
        
        # Check for log file creation (indicates service is initializing)
        $binaryPath = $serviceDetails.PathName
        if ($binaryPath -match '--log-dir\s+"([^"]+)"') {
            $logDir = $matches[1]
            if (Test-Path $logDir) {
                $recentLogs = Get-ChildItem -Path $logDir -Filter "*.log" | Where-Object { $_.LastWriteTime -gt (Get-Date).AddMinutes(-2) }
                if ($recentLogs) {
                    Write-InstallationLog -Level Success -Message "Service is generating log files - initialization in progress"
                }
                else {
                    Write-InstallationLog -Level Info -Message "No recent log files found - service may still be initializing"
                }
            }
        }
        
        Write-InstallationLog -Level Success -Message "Post-startup health checks completed"
        return $true
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Post-startup health check failed: $($_.Exception.Message)"
        return $false
    }
}

function Test-BridgeServiceStatus {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName
    )
    
    Write-InstallationLog -Level Debug -Message "Verifying bridge service status..."
    
    try {
        # Get service information
        $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $service) {
            Write-InstallationLog -Level Error -Message "Service '$ServiceName' not found"
            return $false
        }
        
        # Check basic service status
        if ($service.Status -ne 'Running') {
            Write-InstallationLog -Level Error -Message "Service is not running. Status: $($service.Status)"
            return $false
        }
        
        # Get detailed service information
        $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
        if ($serviceDetails) {
            Write-InstallationLog -Level Info -Message "Service Status Verification:"
            Write-InstallationLog -Level Info -Message "  Status: $($serviceDetails.State)"
            Write-InstallationLog -Level Info -Message "  Process ID: $($serviceDetails.ProcessId)"
            Write-InstallationLog -Level Info -Message "  Start Mode: $($serviceDetails.StartMode)"
            
            # Verify the process is actually running
            if ($serviceDetails.ProcessId -and $serviceDetails.ProcessId -gt 0) {
                $process = Get-Process -Id $serviceDetails.ProcessId -ErrorAction SilentlyContinue
                if ($process) {
                    Write-InstallationLog -Level Success -Message "  Process verified: $($process.ProcessName) (PID: $($process.Id))"
                    Write-InstallationLog -Level Info -Message "  Process start time: $($process.StartTime)"
                    Write-InstallationLog -Level Info -Message "  Working set: $([math]::Round($process.WorkingSet / 1MB, 2)) MB"
                }
                else {
                    Write-InstallationLog -Level Warning -Message "  Process ID $($serviceDetails.ProcessId) not found in process list"
                    return $false
                }
            }
            else {
                Write-InstallationLog -Level Warning -Message "  No valid process ID associated with service"
                return $false
            }
        }
        
        # Check if service is set to auto-start
        if ($serviceDetails.StartMode -ne 'Auto') {
            Write-InstallationLog -Level Warning -Message "Service is not set to start automatically. Start mode: $($serviceDetails.StartMode)"
        }
        
        # Additional health checks could be added here:
        # - Check if service is responding to requests
        # - Verify log files are being created
        # - Test basic functionality
        
        Write-InstallationLog -Level Success -Message "Service status verification completed successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Service status verification failed: $($_.Exception.Message)"
        return $false
    }
}

function Get-ServiceStartupError {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName
    )
    
    try {
        # Check Windows Event Log for service startup errors
        $recentEvents = Get-WinEvent -FilterHashtable @{
            LogName='System'
            ID=7034,7031,7030,7009,7000,7001,7023,7024
            StartTime=(Get-Date).AddMinutes(-10)
        } -MaxEvents 20 -ErrorAction SilentlyContinue
        
        $serviceErrors = @()
        
        if ($recentEvents) {
            foreach ($event in $recentEvents) {
                if ($event.Message -like "*$ServiceName*") {
                    $serviceErrors += "Event ID $($event.Id): $($event.Message)"
                }
            }
        }
        
        if ($serviceErrors.Count -gt 0) {
            return "Recent errors: $($serviceErrors -join '; ')"
        }
        else {
            return "No specific error details found in event log"
        }
    }
    catch {
        return "Could not retrieve error details: $($_.Exception.Message)"
    }
}

function Stop-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30,
        
        [Parameter(Mandatory=$false)]
        [switch]$Force
    )
    
    Write-InstallationLog -Level Info -Message "Stopping RepSet Bridge service..."
    
    try {
        # Verify service exists
        $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $service) {
            Write-InstallationLog -Level Warning -Message "Service '$ServiceName' not found"
            return $true
        }
        
        # Check current service status
        if ($service.Status -eq 'Stopped') {
            Write-InstallationLog -Level Info -Message "Service is already stopped"
            return $true
        }
        
        if ($service.Status -eq 'StopPending') {
            Write-InstallationLog -Level Info -Message "Service is already stopping, waiting for completion..."
        }
        else {
            # Stop the service
            Write-InstallationLog -Level Info -Message "Stopping service '$ServiceName'..."
            if ($Force) {
                Stop-Service -Name $ServiceName -Force -ErrorAction Stop
            }
            else {
                Stop-Service -Name $ServiceName -ErrorAction Stop
            }
        }
        
        # Wait for service to stop
        Write-InstallationLog -Level Info -Message "Waiting for service to stop (timeout: $TimeoutSeconds seconds)..."
        
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        $serviceStopped = $false
        
        do {
            Start-Sleep -Seconds 1
            $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
            
            if ($service.Status -eq 'Stopped') {
                $serviceStopped = $true
                break
            }
            
            Write-InstallationLog -Level Debug -Message "Service status: $($service.Status), elapsed: $([math]::Round($stopwatch.Elapsed.TotalSeconds, 1))s"
            
        } while ($stopwatch.Elapsed.TotalSeconds -lt $TimeoutSeconds)
        
        $stopwatch.Stop()
        
        if (-not $serviceStopped) {
            if ($Force) {
                Write-InstallationLog -Level Warning -Message "Service did not stop gracefully, attempting to kill process..."
                & taskkill /F /IM "repset-bridge.exe" 2>$null
                Start-Sleep -Seconds 2
                
                $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
                if ($service.Status -eq 'Stopped') {
                    Write-InstallationLog -Level Warning -Message "Service stopped after process termination"
                    return $true
                }
                else {
                    throw "Service could not be stopped even with force termination"
                }
            }
            else {
                throw "Service failed to stop within $TimeoutSeconds seconds. Status: $($service.Status)"
            }
        }
        
        Write-InstallationLog -Level Success -Message "Service stopped successfully in $([math]::Round($stopwatch.Elapsed.TotalSeconds, 1)) seconds"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to stop bridge service: $($_.Exception.Message)"
        throw
    }
}

function Remove-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName
    )
    
    Write-InstallationLog -Level Info -Message "Removing RepSet Bridge service..."
    
    try {
        # Check if service exists
        $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $service) {
            Write-InstallationLog -Level Info -Message "Service '$ServiceName' not found, nothing to remove"
            return $true
        }
        
        # Stop service if running
        if ($service.Status -ne 'Stopped') {
            Write-InstallationLog -Level Info -Message "Stopping service before removal..."
            Stop-BridgeService -ServiceName $ServiceName -Force
        }
        
        # Remove the service
        Write-InstallationLog -Level Info -Message "Removing service registration..."
        & sc.exe delete $ServiceName | Out-Null
        
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to remove service (sc.exe exit code: $LASTEXITCODE)"
        }
        
        # Verify service was removed
        Start-Sleep -Seconds 2
        $removedService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if ($removedService) {
            throw "Service still exists after removal attempt"
        }
        
        Write-InstallationLog -Level Success -Message "RepSet Bridge service removed successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to remove bridge service: $($_.Exception.Message)"
        throw
    }
}

function Get-ServiceConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName
    )
    
    Write-InstallationLog -Level Debug -Message "Retrieving current service configuration for $ServiceName"
    
    try {
        # Get detailed service information from WMI
        $serviceDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction Stop
        
        if (-not $serviceDetails) {
            throw "Service configuration not found"
        }
        
        # Get service failure actions using sc.exe
        $failureConfig = & sc.exe qfailure $ServiceName 2>$null
        $failureActions = @()
        $resetPeriod = 86400 # Default 24 hours
        
        if ($LASTEXITCODE -eq 0 -and $failureConfig) {
            # Parse failure configuration
            foreach ($line in $failureConfig) {
                if ($line -match "RESET_PERIOD.*?(\d+)") {
                    $resetPeriod = [int]$matches[1]
                }
                if ($line -match "FAILURE_ACTIONS.*?(\w+)/(\d+)") {
                    $failureActions += @{
                        Action = $matches[1]
                        Delay = [int]$matches[2]
                    }
                }
            }
        }
        
        $config = @{
            Name = $serviceDetails.Name
            DisplayName = $serviceDetails.DisplayName
            Description = $serviceDetails.Description
            StartMode = $serviceDetails.StartMode
            ServiceAccount = $serviceDetails.StartName
            BinaryPath = $serviceDetails.PathName
            Dependencies = @()
            FailureActions = $failureActions
            ResetPeriod = $resetPeriod
        }
        
        # Get service dependencies
        if ($serviceDetails.ServicesDependedOn) {
            $config.Dependencies = $serviceDetails.ServicesDependedOn
        }
        
        Write-InstallationLog -Level Debug -Message "Service configuration retrieved successfully"
        return $config
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Could not retrieve service configuration: $($_.Exception.Message)"
        return $null
    }
}

function Update-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName,
        
        [Parameter(Mandatory=$true)]
        [string]$ExecutablePath,
        
        [Parameter(Mandatory=$false)]
        [hashtable]$CurrentConfig
    )
    
    Write-InstallationLog -Level Info -Message "Updating existing bridge service..."
    
    try {
        # Create backup of current service configuration
        $backupConfig = $CurrentConfig
        if (-not $backupConfig) {
            $backupConfig = Get-ServiceConfiguration -ServiceName $ServiceName
        }
        
        # Stop existing service gracefully
        Write-InstallationLog -Level Info -Message "Stopping existing service for upgrade..."
        $stopResult = Stop-BridgeService -ServiceName $ServiceName -TimeoutSeconds 45
        
        if (-not $stopResult) {
            Write-InstallationLog -Level Warning -Message "Service did not stop gracefully, attempting force stop..."
            Stop-BridgeService -ServiceName $ServiceName -Force -TimeoutSeconds 30
        }
        
        # Preserve existing service configuration where possible
        $preservedStartMode = if ($backupConfig -and $backupConfig.StartMode) { $backupConfig.StartMode } else { "Auto" }
        $preservedAccount = if ($backupConfig -and $backupConfig.ServiceAccount) { $backupConfig.ServiceAccount } else { "LocalSystem" }
        
        Write-InstallationLog -Level Info -Message "Preserving service configuration - Start Mode: $preservedStartMode, Account: $preservedAccount"
        
        # Update service binary path
        $configFile = Join-Path (Split-Path $ExecutablePath) "config\$script:ConfigFileName"
        $logDir = Join-Path (Split-Path $ExecutablePath) "logs"
        
        # Build updated service command line
        $serviceArgs = @(
            "--config `"$configFile`""
            "--log-dir `"$logDir`""
            "--service"
        )
        $newServiceCommand = "`"$ExecutablePath`" $($serviceArgs -join ' ')"
        
        Write-InstallationLog -Level Info -Message "Updating service binary path..."
        & sc.exe config $ServiceName binPath= $newServiceCommand | Out-Null
        
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to update service binary path (exit code: $LASTEXITCODE)"
        }
        
        # Restore preserved configuration settings
        if ($preservedStartMode -ne "Auto") {
            $startType = switch ($preservedStartMode) {
                "Manual" { "demand" }
                "Disabled" { "disabled" }
                default { "auto" }
            }
            & sc.exe config $ServiceName start= $startType | Out-Null
        }
        
        if ($preservedAccount -ne "LocalSystem") {
            & sc.exe config $ServiceName obj= $preservedAccount | Out-Null
        }
        
        # Restore failure recovery settings if they existed
        if ($backupConfig -and $backupConfig.FailureActions -and $backupConfig.FailureActions.Count -gt 0) {
            Write-InstallationLog -Level Info -Message "Restoring failure recovery settings..."
            
            $actionStrings = @()
            foreach ($action in $backupConfig.FailureActions) {
                $actionStrings += "$($action.Action)/$($action.Delay)"
            }
            
            if ($actionStrings.Count -gt 0) {
                $failureActions = "reset= $($backupConfig.ResetPeriod) actions= $($actionStrings -join '/')"
                & sc.exe failure $ServiceName $failureActions | Out-Null
            }
        }
        else {
            # Apply default failure recovery settings for new installations
            Write-InstallationLog -Level Info -Message "Applying default failure recovery settings..."
            $failureActions = "reset= 86400 actions= restart/60000/restart/120000/none/0"
            & sc.exe failure $ServiceName $failureActions | Out-Null
        }
        
        # Set service dependencies (network services)
        & sc.exe config $ServiceName depend= "Tcpip/Dhcp" | Out-Null
        
        # Verify service configuration was updated successfully
        $updatedService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
        if (-not $updatedService) {
            throw "Service not found after configuration update"
        }
        
        # Get updated service details for verification
        $updatedDetails = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction SilentlyContinue
        if ($updatedDetails) {
            Write-InstallationLog -Level Info -Message "Updated Service Configuration:"
            Write-InstallationLog -Level Info -Message "  Binary Path: $($updatedDetails.PathName)"
            Write-InstallationLog -Level Info -Message "  Start Mode: $($updatedDetails.StartMode)"
            Write-InstallationLog -Level Info -Message "  Service Account: $($updatedDetails.StartName)"
        }
        
        Write-InstallationLog -Level Success -Message "Service configuration updated successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Service update failed: $($_.Exception.Message)"
        
        # Attempt to restore service if update failed
        if ($backupConfig) {
            Write-InstallationLog -Level Warning -Message "Attempting to restore previous service configuration..."
            try {
                Restore-ServiceConfiguration -ServiceName $ServiceName -BackupConfig $backupConfig
                Write-InstallationLog -Level Info -Message "Previous service configuration restored"
            }
            catch {
                Write-InstallationLog -Level Error -Message "Failed to restore previous configuration: $($_.Exception.Message)"
            }
        }
        
        return $false
    }
}

function Restore-ServiceConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName,
        
        [Parameter(Mandatory=$true)]
        [hashtable]$BackupConfig
    )
    
    Write-InstallationLog -Level Info -Message "Restoring service configuration from backup..."
    
    try {
        # Restore binary path
        if ($BackupConfig.BinaryPath) {
            & sc.exe config $ServiceName binPath= $BackupConfig.BinaryPath | Out-Null
        }
        
        # Restore start mode
        if ($BackupConfig.StartMode) {
            $startType = switch ($BackupConfig.StartMode) {
                "Auto" { "auto" }
                "Manual" { "demand" }
                "Disabled" { "disabled" }
                default { "auto" }
            }
            & sc.exe config $ServiceName start= $startType | Out-Null
        }
        
        # Restore service account
        if ($BackupConfig.ServiceAccount) {
            & sc.exe config $ServiceName obj= $BackupConfig.ServiceAccount | Out-Null
        }
        
        # Restore failure actions
        if ($BackupConfig.FailureActions -and $BackupConfig.FailureActions.Count -gt 0) {
            $actionStrings = @()
            foreach ($action in $BackupConfig.FailureActions) {
                $actionStrings += "$($action.Action)/$($action.Delay)"
            }
            
            $failureActions = "reset= $($BackupConfig.ResetPeriod) actions= $($actionStrings -join '/')"
            & sc.exe failure $ServiceName $failureActions | Out-Null
        }
        
        Write-InstallationLog -Level Success -Message "Service configuration restored from backup"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to restore service configuration: $($_.Exception.Message)"
        return $false
    }
}

# ================================================================
# Existing Installation Detection and Upgrade Handling Functions
# ================================================================

function Test-ExistingInstallation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$InstallPath = "$env:ProgramFiles\RepSet\Bridge",
        
        [Parameter(Mandatory=$false)]
        [string]$ServiceName = $script:ServiceName
    )
    
    Write-InstallationLog -Level Info -Message "Checking for existing RepSet Bridge installation..."
    
    $existingInstallation = @{
        Found = $false
        ServiceExists = $false
        ServiceRunning = $false
        InstallationPath = ""
        ConfigurationPath = ""
        Version = ""
        ConfigurationValid = $false
        BackupRequired = $false
        # Enhanced detection properties
        HasService = $false
        HasExecutable = $false
        HasConfiguration = $false
        ServiceStatus = "Not Found"
        ServiceVersion = ""
        ExecutableVersion = ""
        LogsPath = ""
        InstallationMethod = "Unknown"
        LastModified = $null
        CanUpgrade = $false
        RequiresCleanInstall = $false
    }
    
    try {
        # Check if service exists
        $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
        if ($service) {
            $existingInstallation.ServiceExists = $true
            $existingInstallation.HasService = $true
            $existingInstallation.ServiceRunning = $service.Status -eq 'Running'
            $existingInstallation.ServiceStatus = $service.Status
            $existingInstallation.Found = $true
            
            Write-InstallationLog -Level Info -Message "Found existing RepSet Bridge service (Status: $($service.Status))"
            
            # Try to determine installation path from service
            try {
                $serviceConfig = Get-WmiObject -Class Win32_Service -Filter "Name='$script:ServiceName'" -ErrorAction SilentlyContinue
                if ($serviceConfig -and $serviceConfig.PathName) {
                    $servicePath = $serviceConfig.PathName -replace '"', ''
                    if (Test-Path $servicePath) {
                        $existingInstallation.InstallationPath = Split-Path $servicePath -Parent
                        $existingInstallation.HasExecutable = $true
                        Write-InstallationLog -Level Info -Message "Service executable found at: $servicePath"
                        
                        # Try to get version information
                        try {
                            $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($servicePath)
                            if ($versionInfo.FileVersion) {
                                $existingInstallation.Version = $versionInfo.FileVersion
                                $existingInstallation.ExecutableVersion = $versionInfo.FileVersion
                                $existingInstallation.ServiceVersion = $versionInfo.FileVersion
                                $existingInstallation.LastModified = (Get-Item $servicePath).LastWriteTime
                                Write-InstallationLog -Level Info -Message "Existing bridge version: $($existingInstallation.Version)"
                            }
                        }
                        catch {
                            Write-InstallationLog -Level Debug -Message "Could not determine existing bridge version: $($_.Exception.Message)"
                        }
                    }
                }
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Could not determine service path: $($_.Exception.Message)"
            }
        }
        
        # Check common installation paths if service path detection failed
        if (-not $existingInstallation.InstallationPath) {
            $commonPaths = @(
                "$env:ProgramFiles\RepSet\Bridge",
                "$env:ProgramFiles(x86)\RepSet\Bridge",
                "$env:LOCALAPPDATA\RepSet\Bridge",
                $InstallPath
            )
            
            foreach ($path in $commonPaths) {
                if (Test-Path $path) {
                    $bridgeExe = Join-Path $path "gym-door-bridge.exe"
                    if (Test-Path $bridgeExe) {
                        $existingInstallation.Found = $true
                        $existingInstallation.HasExecutable = $true
                        $existingInstallation.InstallationPath = $path
                        Write-InstallationLog -Level Info -Message "Found existing bridge installation at: $path"
                        
                        # Try to get version from executable
                        try {
                            $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($bridgeExe)
                            if ($versionInfo.FileVersion) {
                                $existingInstallation.Version = $versionInfo.FileVersion
                                $existingInstallation.ExecutableVersion = $versionInfo.FileVersion
                                $existingInstallation.LastModified = (Get-Item $bridgeExe).LastWriteTime
                                Write-InstallationLog -Level Info -Message "Existing bridge version: $($existingInstallation.Version)"
                            }
                        }
                        catch {
                            Write-InstallationLog -Level Debug -Message "Could not determine bridge version from executable"
                        }
                        break
                    }
                }
            }
        }
        
        # Check for existing configuration
        if ($existingInstallation.InstallationPath) {
            $configPaths = @(
                Join-Path $existingInstallation.InstallationPath "config\$script:ConfigFileName",
                Join-Path $existingInstallation.InstallationPath "$script:ConfigFileName"
            )
            
            foreach ($configPath in $configPaths) {
                if (Test-Path $configPath) {
                    $existingInstallation.ConfigurationPath = $configPath
                    $existingInstallation.HasConfiguration = $true
                    $existingInstallation.ConfigurationValid = Test-BridgeConfiguration -ConfigPath $configPath
                    $existingInstallation.BackupRequired = $true
                    Write-InstallationLog -Level Info -Message "Found existing configuration at: $configPath"
                    break
                }
            }
            
            # Check for logs directory
            $logsPath = Join-Path $existingInstallation.InstallationPath "logs"
            if (Test-Path $logsPath) {
                $existingInstallation.LogsPath = $logsPath
            }
        }
        
        # Determine installation method from service description or registry
        if ($existingInstallation.HasService) {
            try {
                $serviceDescription = (Get-WmiObject -Class Win32_Service -Filter "Name='$script:ServiceName'").Description
                if ($serviceDescription -like "*automated-installer*") {
                    $existingInstallation.InstallationMethod = "Automated"
                }
                elseif ($serviceDescription -like "*manual*") {
                    $existingInstallation.InstallationMethod = "Manual"
                }
            }
            catch {
                # Ignore errors in determining installation method
            }
        }
        
        # Determine upgrade capability
        $existingInstallation.CanUpgrade = $existingInstallation.HasService -and $existingInstallation.HasExecutable
        $existingInstallation.RequiresCleanInstall = $existingInstallation.HasService -and -not $existingInstallation.HasExecutable
        }
        
        if ($existingInstallation.Found) {
            Write-InstallationLog -Level Warning -Message "Existing RepSet Bridge installation detected:"
            Write-InstallationLog -Level Info -Message "  Service: $($existingInstallation.HasService) ($($existingInstallation.ServiceStatus))"
            Write-InstallationLog -Level Info -Message "  Executable: $($existingInstallation.HasExecutable) (Version: $($existingInstallation.ExecutableVersion))"
            Write-InstallationLog -Level Info -Message "  Configuration: $($existingInstallation.HasConfiguration) (Valid: $($existingInstallation.ConfigurationValid))"
            Write-InstallationLog -Level Info -Message "  Installation Path: $($existingInstallation.InstallationPath)"
            Write-InstallationLog -Level Info -Message "  Installation Method: $($existingInstallation.InstallationMethod)"
            Write-InstallationLog -Level Info -Message "  Can Upgrade: $($existingInstallation.CanUpgrade)"
            Write-InstallationLog -Level Info -Message "  Requires Clean Install: $($existingInstallation.RequiresCleanInstall)"
        }
        else {
            Write-InstallationLog -Level Success -Message "No existing RepSet Bridge installation found - proceeding with fresh installation"
        }
        
        return $existingInstallation
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error checking for existing installation: $($_.Exception.Message)"
        return $existingInstallation
    }
}

function Test-BridgeConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ConfigPath
    )
    
    try {
        if (-not (Test-Path $ConfigPath)) {
            return $false
        }
        
        $configContent = Get-Content $ConfigPath -Raw -ErrorAction SilentlyContinue
        if (-not $configContent) {
            return $false
        }
        
        # Basic validation - check for required fields
        $hasDeviceId = $configContent -match 'device_id\s*:'
        $hasDeviceKey = $configContent -match 'device_key\s*:'
        $hasServerUrl = $configContent -match 'server_url\s*:'
        
        return $hasDeviceId -and $hasDeviceKey -and $hasServerUrl
    }
    catch {
        Write-InstallationLog -Level Debug -Message "Error validating configuration: $($_.Exception.Message)"
        return $false
    }
}

function Confirm-InstallationAction {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ExistingInstallation,
        
        [Parameter(Mandatory=$false)]
        [switch]$Force
    )
    
    # If Force is specified, skip confirmation
    if ($Force) {
        Write-InstallationLog -Level Info -Message "Force flag specified - skipping confirmation prompts"
        return @{
            Action = "Upgrade"
            Confirmed = $true
            PreserveConfiguration = $true
            BackupExisting = $true
        }
    }
    
    # If no existing installation, no confirmation needed
    if (-not $ExistingInstallation.Found) {
        return @{
            Action = "FreshInstall"
            Confirmed = $true
            PreserveConfiguration = $false
            BackupExisting = $false
        }
    }
    
    Write-InstallationLog -Level Warning -Message ""
    Write-InstallationLog -Level Warning -Message "⚠️  EXISTING INSTALLATION DETECTED"
    Write-InstallationLog -Level Warning -Message ""
    Write-InstallationLog -Level Info -Message "Current installation details:"
    Write-InstallationLog -Level Info -Message "  Service Status: $($ExistingInstallation.ServiceStatus)"
    Write-InstallationLog -Level Info -Message "  Executable Version: $($ExistingInstallation.ExecutableVersion)"
    Write-InstallationLog -Level Info -Message "  Configuration Valid: $($ExistingInstallation.ConfigurationValid)"
    Write-InstallationLog -Level Info -Message "  Installation Path: $($ExistingInstallation.InstallationPath)"
    Write-InstallationLog -Level Info -Message "  Last Modified: $($ExistingInstallation.LastModified)"
    Write-InstallationLog -Level Warning -Message ""
    
    # Determine recommended action
    $recommendedAction = if ($ExistingInstallation.CanUpgrade) {
        "Upgrade"
    } elseif ($ExistingInstallation.RequiresCleanInstall) {
        "CleanInstall"
    } else {
        "Reinstall"
    }
    
    # For automated installation, proceed with recommended action after timeout
    Write-InstallationLog -Level Info -Message "Recommended action: $recommendedAction"
    Write-InstallationLog -Level Warning -Message ""
    Write-InstallationLog -Level Warning -Message "Proceeding with $recommendedAction in 15 seconds..."
    Write-InstallationLog -Level Info -Message "Press Ctrl+C to cancel if you do not want to proceed."
    Write-InstallationLog -Level Warning -Message ""
    
    try {
        Start-Sleep -Seconds 15
        Write-InstallationLog -Level Info -Message "Proceeding with $recommendedAction"
        
        switch ($recommendedAction) {
            "Upgrade" {
                return @{
                    Action = "Upgrade"
                    Confirmed = $true
                    PreserveConfiguration = $true
                    BackupExisting = $true
                }
            }
            "Reinstall" {
                return @{
                    Action = "Reinstall"
                    Confirmed = $true
                    PreserveConfiguration = $true
                    BackupExisting = $true
                }
            }
            "CleanInstall" {
                return @{
                    Action = "CleanInstall"
                    Confirmed = $true
                    PreserveConfiguration = $false
                    BackupExisting = $true
                }
            }
        }
    }
    catch {
        Write-InstallationLog -Level Info -Message "Installation cancelled by user"
        return @{
            Action = "Abort"
            Confirmed = $false
            PreserveConfiguration = $false
            BackupExisting = $false
        }
    }
}

function Stop-ExistingBridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ExistingInstallation
    )
    
    if (-not $ExistingInstallation.ServiceExists) {
        Write-InstallationLog -Level Info -Message "No existing service to stop"
        return $true
    }
    
    Write-InstallationLog -Level Info -Message "Stopping existing RepSet Bridge service..."
    
    try {
        $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
        if ($service -and $service.Status -eq 'Running') {
            Write-InstallationLog -Level Info -Message "Stopping service: $script:ServiceName"
            Stop-Service -Name $script:ServiceName -Force -ErrorAction Stop
            
            # Wait for service to stop with timeout
            $timeout = 30
            $elapsed = 0
            while ($elapsed -lt $timeout) {
                $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
                if ($service.Status -eq 'Stopped') {
                    Write-InstallationLog -Level Success -Message "Service stopped successfully"
                    return $true
                }
                Start-Sleep -Seconds 2
                $elapsed += 2
                Write-InstallationLog -Level Info -Message "Waiting for service to stop... ($elapsed/$timeout seconds)"
            }
            
            Write-InstallationLog -Level Warning -Message "Service did not stop within timeout period, but continuing with installation"
            return $true
        }
        else {
            Write-InstallationLog -Level Info -Message "Service is already stopped"
            return $true
        }
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error stopping existing service: $($_.Exception.Message)"
        Write-InstallationLog -Level Warning -Message "Continuing with installation despite service stop failure"
        return $false
    }
}

function Backup-ExistingInstallation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ExistingInstallation,
        
        [Parameter(Mandatory=$false)]
        [string]$BackupPath = "$env:TEMP\RepSetBridge-Backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
    )
    
    Write-InstallationLog -Level Info -Message "Creating backup of existing installation..."
    
    $backupInfo = @{
        BackupPath = $BackupPath
        Success = $false
        ConfigurationBackup = ""
        ExecutableBackup = ""
        ServiceConfigBackup = ""
        LogsBackup = ""
        BackupSize = 0
        BackupTime = Get-Date
        ConfigurationData = @{}
    }
    
    if (-not $ExistingInstallation.Found) {
        Write-InstallationLog -Level Info -Message "No existing installation to backup"
        $backupInfo.Success = $true
        return $backupInfo
    }
    
    try {
        # Create backup directory
        if (-not (Test-Path $BackupPath)) {
            New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        }
        
        Write-InstallationLog -Level Info -Message "Backup location: $BackupPath"
        
        # Backup configuration files
        if ($ExistingInstallation.HasConfiguration -and $ExistingInstallation.ConfigurationPath) {
            $configBackupPath = Join-Path $BackupPath "config"
            New-Item -Path $configBackupPath -ItemType Directory -Force | Out-Null
            
            $configFile = $ExistingInstallation.ConfigurationPath
            $configBackupFile = Join-Path $configBackupPath (Split-Path $configFile -Leaf)
            Copy-Item -Path $configFile -Destination $configBackupFile -Force
            $backupInfo.ConfigurationBackup = $configBackupFile
            
            Write-InstallationLog -Level Success -Message "Configuration backed up: $configBackupFile"
        }
        
        # Backup executable
        if ($ExistingInstallation.HasExecutable -and $ExistingInstallation.InstallationPath) {
            $executablePath = Join-Path $ExistingInstallation.InstallationPath "gym-door-bridge.exe"
            if (Test-Path $executablePath) {
                $executableBackupPath = Join-Path $BackupPath "gym-door-bridge.exe"
                Copy-Item -Path $executablePath -Destination $executableBackupPath -Force
                $backupInfo.ExecutableBackup = $executableBackupPath
                
                Write-InstallationLog -Level Success -Message "Executable backed up: $executableBackupPath"
            }
        }
        
        # Backup service configuration
        if ($ExistingInstallation.HasService) {
            $serviceConfigPath = Join-Path $BackupPath "service-config.json"
            $serviceConfig = Get-ServiceConfiguration -ServiceName $script:ServiceName
            $serviceConfig | ConvertTo-Json -Depth 3 | Out-File -FilePath $serviceConfigPath -Encoding UTF8
            $backupInfo.ServiceConfigBackup = $serviceConfigPath
            
            Write-InstallationLog -Level Success -Message "Service configuration backed up: $serviceConfigPath"
        }
        
        # Backup logs (last 7 days only to save space)
        if ($ExistingInstallation.LogsPath -and (Test-Path $ExistingInstallation.LogsPath)) {
            $logsBackupPath = Join-Path $BackupPath "logs"
            New-Item -Path $logsBackupPath -ItemType Directory -Force | Out-Null
            
            $recentLogs = Get-ChildItem -Path $ExistingInstallation.LogsPath -File | 
                Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }
            
            foreach ($logFile in $recentLogs) {
                $logBackupFile = Join-Path $logsBackupPath $logFile.Name
                Copy-Item -Path $logFile.FullName -Destination $logBackupFile -Force
            }
            
            $backupInfo.LogsBackup = $logsBackupPath
            Write-InstallationLog -Level Success -Message "Recent logs backed up: $logsBackupPath ($($recentLogs.Count) files)"
        }
        
        # Parse configuration for preservation
        if ($ExistingInstallation.ConfigurationPath -and (Test-Path $ExistingInstallation.ConfigurationPath)) {
            try {
                $configContent = Get-Content $ExistingInstallation.ConfigurationPath -Raw
                
                # Extract key configuration values using regex
                if ($configContent -match 'device_id\s*:\s*["\']?([^"\'\r\n]+)["\']?') {
                    $backupInfo.ConfigurationData.DeviceId = $matches[1].Trim()
                }
                if ($configContent -match 'device_key\s*:\s*["\']?([^"\'\r\n]+)["\']?') {
                    $backupInfo.ConfigurationData.DeviceKey = $matches[1].Trim()
                }
                if ($configContent -match 'server_url\s*:\s*["\']?([^"\'\r\n]+)["\']?') {
                    $backupInfo.ConfigurationData.ServerUrl = $matches[1].Trim()
                }
                if ($configContent -match 'tier\s*:\s*["\']?([^"\'\r\n]+)["\']?') {
                    $backupInfo.ConfigurationData.Tier = $matches[1].Trim()
                }
                
                Write-InstallationLog -Level Info -Message "Extracted configuration data for preservation"
                Write-InstallationLog -Level Debug -Message "Device ID: $($backupInfo.ConfigurationData.DeviceId)"
                Write-InstallationLog -Level Debug -Message "Server URL: $($backupInfo.ConfigurationData.ServerUrl)"
                Write-InstallationLog -Level Debug -Message "Tier: $($backupInfo.ConfigurationData.Tier)"
            }
            catch {
                Write-InstallationLog -Level Warning -Message "Could not parse existing configuration for preservation: $($_.Exception.Message)"
            }
        }
        
        # Calculate backup size
        $backupSize = (Get-ChildItem -Path $BackupPath -Recurse -File | Measure-Object -Property Length -Sum).Sum
        $backupInfo.BackupSize = $backupSize
        
        # Create backup manifest
        $manifest = @{
            BackupTime = $backupInfo.BackupTime
            OriginalInstallation = $ExistingInstallation
            BackupContents = $backupInfo
            BackupSizeMB = [math]::Round($backupSize / 1MB, 2)
        }
        
        $manifestPath = Join-Path $BackupPath "backup-manifest.json"
        $manifest | ConvertTo-Json -Depth 5 | Out-File -FilePath $manifestPath -Encoding UTF8
        
        $backupInfo.Success = $true
        Write-InstallationLog -Level Success -Message "Backup completed successfully"
        Write-InstallationLog -Level Info -Message "Backup size: $([math]::Round($backupSize / 1MB, 2)) MB"
        Write-InstallationLog -Level Info -Message "Backup manifest: $manifestPath"
        
        return $backupInfo
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to create backup: $($_.Exception.Message)"
        $backupInfo.Success = $false
        return $backupInfo
    }
}

function Get-ServiceConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName
    )
    
    try {
        $service = Get-Service -Name $ServiceName -ErrorAction Stop
        $serviceWmi = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'" -ErrorAction Stop
        
        $config = @{
            Name = $service.Name
            DisplayName = $service.DisplayName
            Status = $service.Status
            StartType = $service.StartType
            ServiceType = $serviceWmi.ServiceType
            ErrorControl = $serviceWmi.ErrorControl
            PathName = $serviceWmi.PathName
            StartName = $serviceWmi.StartName
            Description = $serviceWmi.Description
            Dependencies = @()
        }
        
        # Get service dependencies
        $dependencies = $service.ServicesDependedOn
        if ($dependencies) {
            $config.Dependencies = $dependencies | ForEach-Object { $_.Name }
        }
        
        return $config
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Could not retrieve service configuration: $($_.Exception.Message)"
        return @{}
    }
}

function Update-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ServiceName,
        
        [Parameter(Mandatory=$true)]
        [string]$NewExecutablePath,
        
        [Parameter(Mandatory=$true)]
        [hashtable]$CurrentConfig,
        
        [Parameter(Mandatory=$false)]
        [string]$NewConfigPath = ""
    )
    
    Write-InstallationLog -Level Info -Message "Updating existing bridge service..."
    
    try {
        # Stop the service if it's running
        $service = Get-Service -Name $ServiceName -ErrorAction Stop
        if ($service.Status -eq 'Running') {
            Write-InstallationLog -Level Info -Message "Stopping service for upgrade..."
            Stop-Service -Name $ServiceName -Force -TimeoutSec 30
            
            # Wait for service to fully stop
            $timeout = 30
            $elapsed = 0
            while ((Get-Service -Name $ServiceName).Status -ne 'Stopped' -and $elapsed -lt $timeout) {
                Start-Sleep -Seconds 1
                $elapsed++
            }
            
            if ((Get-Service -Name $ServiceName).Status -ne 'Stopped') {
                Write-InstallationLog -Level Warning -Message "Service did not stop within timeout - forcing termination"
                # Force kill any remaining processes
                Get-Process -Name "gym-door-bridge" -ErrorAction SilentlyContinue | Stop-Process -Force
            }
            
            Write-InstallationLog -Level Success -Message "Service stopped successfully"
        }
        
        # Update service executable path
        $newServiceCommand = "`"$NewExecutablePath`""
        if ($NewConfigPath) {
            $newServiceCommand += " --config `"$NewConfigPath`""
        }
        $newServiceCommand += " --service"
        
        Write-InstallationLog -Level Info -Message "Updating service executable path..."
        & sc.exe config $ServiceName binPath= $newServiceCommand | Out-Null
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to update service executable path (sc.exe exit code: $LASTEXITCODE)"
        }
        
        # Preserve other service settings if they were customized
        if ($CurrentConfig.DisplayName -and $CurrentConfig.DisplayName -ne $script:ServiceDisplayName) {
            & sc.exe config $ServiceName DisplayName= $CurrentConfig.DisplayName | Out-Null
        }
        
        if ($CurrentConfig.Description -and $CurrentConfig.Description -ne $script:ServiceDescription) {
            & sc.exe description $ServiceName $CurrentConfig.Description | Out-Null
        }
        
        # Update service description to indicate automated upgrade
        $upgradeDescription = "$script:ServiceDescription (Updated by automated-installer on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss'))"
        & sc.exe description $ServiceName $upgradeDescription | Out-Null
        
        Write-InstallationLog -Level Success -Message "Service configuration updated successfully"
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to update bridge service: $($_.Exception.Message)"
        return $false
    }
}

function Remove-ExistingInstallation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ExistingInstallation,
        
        [Parameter(Mandatory=$false)]
        [switch]$PreserveConfiguration,
        
        [Parameter(Mandatory=$false)]
        [switch]$PreserveLogs
    )
    
    Write-InstallationLog -Level Info -Message "Removing existing installation..."
    
    $removalSuccess = $true
    $removalErrors = @()
    
    try {
        # Stop and remove service
        if ($ExistingInstallation.HasService) {
            try {
                Write-InstallationLog -Level Info -Message "Stopping and removing existing service..."
                
                $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
                if ($service -and $service.Status -eq 'Running') {
                    Stop-Service -Name $script:ServiceName -Force -TimeoutSec 30
                    Write-InstallationLog -Level Success -Message "Service stopped"
                }
                
                # Remove service
                & sc.exe delete $script:ServiceName | Out-Null
                if ($LASTEXITCODE -eq 0) {
                    Write-InstallationLog -Level Success -Message "Service removed successfully"
                } else {
                    $removalErrors += "Failed to remove service (sc.exe exit code: $LASTEXITCODE)"
                    Write-InstallationLog -Level Error -Message $removalErrors[-1]
                    $removalSuccess = $false
                }
            }
            catch {
                $removalErrors += "Failed to remove service: $($_.Exception.Message)"
                Write-InstallationLog -Level Error -Message $removalErrors[-1]
                $removalSuccess = $false
            }
        }
        
        # Remove executable and installation directory
        if ($ExistingInstallation.InstallationPath -and (Test-Path $ExistingInstallation.InstallationPath)) {
            try {
                Write-InstallationLog -Level Info -Message "Removing installation directory: $($ExistingInstallation.InstallationPath)"
                
                # Preserve configuration if requested
                $configBackup = $null
                if ($PreserveConfiguration -and $ExistingInstallation.ConfigurationPath -and (Test-Path $ExistingInstallation.ConfigurationPath)) {
                    $configBackup = "$env:TEMP\repset-config-preserve-$(Get-Date -Format 'yyyyMMddHHmmss').yaml"
                    Copy-Item -Path $ExistingInstallation.ConfigurationPath -Destination $configBackup -Force
                    Write-InstallationLog -Level Info -Message "Configuration preserved at: $configBackup"
                }
                
                # Preserve logs if requested
                $logsBackup = $null
                if ($PreserveLogs -and $ExistingInstallation.LogsPath -and (Test-Path $ExistingInstallation.LogsPath)) {
                    $logsBackup = "$env:TEMP\repset-logs-preserve-$(Get-Date -Format 'yyyyMMddHHmmss')"
                    Copy-Item -Path $ExistingInstallation.LogsPath -Destination $logsBackup -Recurse -Force
                    Write-InstallationLog -Level Info -Message "Logs preserved at: $logsBackup"
                }
                
                # Force remove installation directory
                Remove-Item -Path $ExistingInstallation.InstallationPath -Recurse -Force -ErrorAction Stop
                Write-InstallationLog -Level Success -Message "Installation directory removed"
                
                # Store preserved paths for later restoration
                if ($configBackup) {
                    $script:PreservedConfigPath = $configBackup
                }
                if ($logsBackup) {
                    $script:PreservedLogsPath = $logsBackup
                }
            }
            catch {
                $removalErrors += "Failed to remove installation directory: $($_.Exception.Message)"
                Write-InstallationLog -Level Error -Message $removalErrors[-1]
                $removalSuccess = $false
            }
        }
        
        # Clean up any remaining processes
        try {
            $bridgeProcesses = Get-Process -Name "gym-door-bridge" -ErrorAction SilentlyContinue
            if ($bridgeProcesses) {
                Write-InstallationLog -Level Info -Message "Terminating remaining bridge processes..."
                $bridgeProcesses | Stop-Process -Force
                Write-InstallationLog -Level Success -Message "Bridge processes terminated"
            }
        }
        catch {
            $removalErrors += "Failed to terminate bridge processes: $($_.Exception.Message)"
            Write-InstallationLog -Level Warning -Message $removalErrors[-1]
        }
        
        # Log removal summary
        if ($removalSuccess) {
            Write-InstallationLog -Level Success -Message "Existing installation removed successfully"
            if ($removalErrors.Count -gt 0) {
                Write-InstallationLog -Level Warning -Message "Removal completed with warnings:"
                foreach ($error in $removalErrors) {
                    Write-InstallationLog -Level Warning -Message "  - $error"
                }
            }
        } else {
            Write-InstallationLog -Level Error -Message "Failed to completely remove existing installation"
            Write-InstallationLog -Level Error -Message "Removal errors:"
            foreach ($error in $removalErrors) {
                Write-InstallationLog -Level Error -Message "  - $error"
            }
        }
        
        return $removalSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Critical error during installation removal: $($_.Exception.Message)"
        return $false
    }
}

function Restore-ConfigurationSettings {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$BackupData,
        
        [Parameter(Mandatory=$true)]
        [string]$NewConfigPath
    )
    
    if (-not $BackupData.Success -or $BackupData.ConfigurationData.Count -eq 0) {
        Write-InstallationLog -Level Info -Message "No configuration data to preserve"
        return $true
    }
    
    Write-InstallationLog -Level Info -Message "Preserving existing configuration settings..."
    
    try {
        if (-not (Test-Path $NewConfigPath)) {
            Write-InstallationLog -Level Warning -Message "New configuration file not found at: $NewConfigPath"
            return $false
        }
        
        $configContent = Get-Content $NewConfigPath -Raw
        $preservedData = $BackupData.ConfigurationData
        
        # Preserve device_id if it exists and is different from new generated one
        if ($preservedData.DeviceId -and $preservedData.DeviceId -ne "gym-$GymId-$(Get-Date -Format 'yyyyMMddHHmmss')") {
            $configContent = $configContent -replace 'device_id\s*:\s*["\']?[^"\'\r\n]+["\']?', "device_id: `"$($preservedData.DeviceId)`""
            Write-InstallationLog -Level Info -Message "Preserved existing device ID: $($preservedData.DeviceId)"
        }
        
        # Preserve server_url if it's different from the new one
        if ($preservedData.ServerUrl -and $preservedData.ServerUrl -ne $PlatformEndpoint) {
            $configContent = $configContent -replace 'server_url\s*:\s*["\']?[^"\'\r\n]+["\']?', "server_url: `"$($preservedData.ServerUrl)`""
            Write-InstallationLog -Level Info -Message "Preserved existing server URL: $($preservedData.ServerUrl)"
        }
        
        # Preserve tier setting
        if ($preservedData.Tier) {
            $configContent = $configContent -replace 'tier\s*:\s*["\']?[^"\'\r\n]+["\']?', "tier: `"$($preservedData.Tier)`""
            Write-InstallationLog -Level Info -Message "Preserved existing tier setting: $($preservedData.Tier)"
        }
        
        # Write updated configuration
        Set-Content -Path $NewConfigPath -Value $configContent -Force
        Write-InstallationLog -Level Success -Message "Configuration settings preserved successfully"
        
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Error preserving configuration settings: $($_.Exception.Message)"
        Write-InstallationLog -Level Warning -Message "Continuing with new configuration"
        return $false
    }
}

function Restore-PreservedConfiguration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$InstallPath,
        
        [Parameter(Mandatory=$false)]
        [string]$PreservedConfigPath = $script:PreservedConfigPath,
        
        [Parameter(Mandatory=$false)]
        [string]$PreservedLogsPath = $script:PreservedLogsPath
    )
    
    Write-InstallationLog -Level Info -Message "Restoring preserved configuration and logs..."
    
    try {
        # Restore configuration
        if ($PreservedConfigPath -and (Test-Path $PreservedConfigPath)) {
            $targetConfigDir = Join-Path $InstallPath "config"
            $targetConfigPath = Join-Path $targetConfigDir $script:ConfigFileName
            
            if (-not (Test-Path $targetConfigDir)) {
                New-Item -Path $targetConfigDir -ItemType Directory -Force | Out-Null
            }
            
            Copy-Item -Path $PreservedConfigPath -Destination $targetConfigPath -Force
            Remove-Item -Path $PreservedConfigPath -Force -ErrorAction SilentlyContinue
            
            Write-InstallationLog -Level Success -Message "Configuration restored from preserved backup"
        }
        
        # Restore logs
        if ($PreservedLogsPath -and (Test-Path $PreservedLogsPath)) {
            $targetLogsPath = Join-Path $InstallPath "logs"
            
            if (-not (Test-Path $targetLogsPath)) {
                New-Item -Path $targetLogsPath -ItemType Directory -Force | Out-Null
            }
            
            Copy-Item -Path "$PreservedLogsPath\*" -Destination $targetLogsPath -Recurse -Force
            Remove-Item -Path $PreservedLogsPath -Recurse -Force -ErrorAction SilentlyContinue
            
            Write-InstallationLog -Level Success -Message "Logs restored from preserved backup"
        }
        
        return $true
    }
    catch {
        Write-InstallationLog -Level Error -Message "Failed to restore preserved configuration: $($_.Exception.Message)"
        return $false
    }
}

function Invoke-InstallationRollback {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$BackupInfo,
        
        [Parameter(Mandatory=$false)]
        [string]$RollbackReason = "Installation failed"
    )
    
    Write-InstallationLog -Level Warning -Message "Initiating installation rollback: $RollbackReason"
    
    $rollbackSuccess = $true
    $rollbackErrors = @()
    
    try {
        if (-not $BackupInfo.Success) {
            Write-InstallationLog -Level Error -Message "Cannot rollback - backup was not successful"
            return $false
        }
        
        if (-not (Test-Path $BackupInfo.BackupPath)) {
            Write-InstallationLog -Level Error -Message "Cannot rollback - backup directory not found: $($BackupInfo.BackupPath)"
            return $false
        }
        
        Write-InstallationLog -Level Info -Message "Rolling back from backup: $($BackupInfo.BackupPath)"
        
        # Stop current service if running
        try {
            $service = Get-Service -Name $script:ServiceName -ErrorAction SilentlyContinue
            if ($service -and $service.Status -eq 'Running') {
                Write-InstallationLog -Level Info -Message "Stopping current service for rollback..."
                Stop-Service -Name $script:ServiceName -Force -TimeoutSec 30
            }
        }
        catch {
            $rollbackErrors += "Failed to stop service: $($_.Exception.Message)"
            Write-InstallationLog -Level Warning -Message $rollbackErrors[-1]
        }
        
        # Restore executable
        if ($BackupInfo.ExecutableBackup -and (Test-Path $BackupInfo.ExecutableBackup)) {
            try {
                $targetExecutable = Join-Path $InstallPath "gym-door-bridge.exe"
                $targetDir = Split-Path $targetExecutable -Parent
                
                if (-not (Test-Path $targetDir)) {
                    New-Item -Path $targetDir -ItemType Directory -Force | Out-Null
                }
                
                Copy-Item -Path $BackupInfo.ExecutableBackup -Destination $targetExecutable -Force
                Write-InstallationLog -Level Success -Message "Executable restored from backup"
            }
            catch {
                $rollbackErrors += "Failed to restore executable: $($_.Exception.Message)"
                Write-InstallationLog -Level Error -Message $rollbackErrors[-1]
                $rollbackSuccess = $false
            }
        }
        
        # Restore configuration
        if ($BackupInfo.ConfigurationBackup -and (Test-Path $BackupInfo.ConfigurationBackup)) {
            try {
                $targetConfig = Join-Path $InstallPath "config\$script:ConfigFileName"
                $targetConfigDir = Split-Path $targetConfig -Parent
                
                if (-not (Test-Path $targetConfigDir)) {
                    New-Item -Path $targetConfigDir -ItemType Directory -Force | Out-Null
                }
                
                Copy-Item -Path $BackupInfo.ConfigurationBackup -Destination $targetConfig -Force
                Write-InstallationLog -Level Success -Message "Configuration restored from backup"
            }
            catch {
                $rollbackErrors += "Failed to restore configuration: $($_.Exception.Message)"
                Write-InstallationLog -Level Error -Message $rollbackErrors[-1]
                $rollbackSuccess = $false
            }
        }
        
        # Restore service configuration
        if ($BackupInfo.ServiceConfigBackup -and (Test-Path $BackupInfo.ServiceConfigBackup)) {
            try {
                $serviceConfig = Get-Content -Path $BackupInfo.ServiceConfigBackup -Raw | ConvertFrom-Json
                
                # Restore service with original configuration
                $executablePath = Join-Path $InstallPath "gym-door-bridge.exe"
                $configPath = Join-Path $InstallPath "config\$script:ConfigFileName"
                
                if (Test-Path $executablePath) {
                    $serviceCommand = "`"$executablePath`" --config `"$configPath`" --service"
                    
                    # Update service path
                    & sc.exe config $script:ServiceName binPath= $serviceCommand | Out-Null
                    if ($LASTEXITCODE -eq 0) {
                        Write-InstallationLog -Level Success -Message "Service configuration restored from backup"
                    } else {
                        $rollbackErrors += "Failed to restore service configuration (sc.exe exit code: $LASTEXITCODE)"
                        Write-InstallationLog -Level Error -Message $rollbackErrors[-1]
                        $rollbackSuccess = $false
                    }
                }
            }
            catch {
                $rollbackErrors += "Failed to restore service configuration: $($_.Exception.Message)"
                Write-InstallationLog -Level Error -Message $rollbackErrors[-1]
                $rollbackSuccess = $false
            }
        }
        
        # Attempt to start the restored service
        if ($rollbackSuccess) {
            try {
                Write-InstallationLog -Level Info -Message "Starting restored service..."
                Start-Service -Name $script:ServiceName
                
                # Wait for service to start
                $timeout = 30
                $elapsed = 0
                while ((Get-Service -Name $script:ServiceName).Status -ne 'Running' -and $elapsed -lt $timeout) {
                    Start-Sleep -Seconds 1
                    $elapsed++
                }
                
                if ((Get-Service -Name $script:ServiceName).Status -eq 'Running') {
                    Write-InstallationLog -Level Success -Message "Restored service started successfully"
                } else {
                    $rollbackErrors += "Restored service failed to start within timeout"
                    Write-InstallationLog -Level Warning -Message $rollbackErrors[-1]
                }
            }
            catch {
                $rollbackErrors += "Failed to start restored service: $($_.Exception.Message)"
                Write-InstallationLog -Level Warning -Message $rollbackErrors[-1]
            }
        }
        
        # Log rollback summary
        if ($rollbackSuccess) {
            Write-InstallationLog -Level Success -Message "Installation rollback completed successfully"
            if ($rollbackErrors.Count -gt 0) {
                Write-InstallationLog -Level Warning -Message "Rollback completed with warnings:"
                foreach ($error in $rollbackErrors) {
                    Write-InstallationLog -Level Warning -Message "  - $error"
                }
            }
        } else {
            Write-InstallationLog -Level Error -Message "Installation rollback failed"
            Write-InstallationLog -Level Error -Message "Rollback errors:"
            foreach ($error in $rollbackErrors) {
                Write-InstallationLog -Level Error -Message "  - $error"
            }
        }
        
        return $rollbackSuccess
    }
    catch {
        Write-InstallationLog -Level Error -Message "Critical error during rollback: $($_.Exception.Message)"
        return $false
    }
}

function Invoke-UpgradeInstallation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ExistingInstallation,
        
        [Parameter(Mandatory=$false)]
        [switch]$Force
    )
    
    Write-InstallationLog -Level Info -Message "Starting upgrade process for existing installation..."
    
    # Get confirmation for installation action
    $confirmationResult = Confirm-InstallationAction -ExistingInstallation $ExistingInstallation -Force:$Force
    if (-not $confirmationResult.Confirmed) {
        Write-InstallationLog -Level Info -Message "Installation cancelled by user"
        return $false
    }
    
    # Create backup if requested
    $backupResult = $null
    if ($confirmationResult.BackupExisting) {
        $backupResult = Backup-ExistingInstallation -ExistingInstallation $ExistingInstallation
        if (-not $backupResult.Success) {
            Write-InstallationLog -Level Warning -Message "Failed to backup existing installation, but continuing"
        }
    }
    
    # Handle different installation actions
    switch ($confirmationResult.Action) {
        "Upgrade" {
            Write-InstallationLog -Level Info -Message "Performing in-place upgrade..."
            # Stop existing service
            $serviceStopResult = Stop-ExistingBridgeService -ExistingInstallation $ExistingInstallation
            if (-not $serviceStopResult) {
                Write-InstallationLog -Level Warning -Message "Failed to stop existing service, but continuing with upgrade"
            }
        }
        "Reinstall" {
            Write-InstallationLog -Level Info -Message "Performing reinstallation with configuration preservation..."
            # Remove existing installation but preserve configuration
            $removalResult = Remove-ExistingInstallation -ExistingInstallation $ExistingInstallation -PreserveConfiguration:$confirmationResult.PreserveConfiguration -PreserveLogs
            if (-not $removalResult) {
                Write-InstallationLog -Level Error -Message "Failed to remove existing installation"
                return $false
            }
        }
        "CleanInstall" {
            Write-InstallationLog -Level Info -Message "Performing clean installation..."
            # Remove existing installation completely
            $removalResult = Remove-ExistingInstallation -ExistingInstallation $ExistingInstallation
            if (-not $removalResult) {
                Write-InstallationLog -Level Error -Message "Failed to remove existing installation"
                return $false
            }
        }
        default {
            Write-InstallationLog -Level Error -Message "Unknown installation action: $($confirmationResult.Action)"
            return $false
        }
    }
    
    # Store backup data and configuration for potential rollback and restoration
    $script:UpgradeBackupData = $backupResult
    $script:ExistingInstallationData = $ExistingInstallation
    $script:InstallationAction = $confirmationResult.Action
    $script:PreserveConfiguration = $confirmationResult.PreserveConfiguration
    
    Write-InstallationLog -Level Success -Message "Upgrade preparation completed successfully"
    Write-InstallationLog -Level Info -Message "Ready to proceed with new installation"
    
    return $true
}

# ================================================================
# Main Installation Function
# ================================================================

# Validate that we're running in an appropriate environment
if (-not $PSVersionTable.PSVersion -or $PSVersionTable.PSVersion.Major -lt 5) {
    Write-Error "PowerShell 5.1 or higher is required"
    exit $script:ErrorCodes.SystemRequirementsNotMet
}

# Main execution
try {
    $exitCode = Install-RepSetBridge
    Write-Host "`nInstallation completed. Log file: $script:LogFile" -ForegroundColor Green
    exit $exitCode
}
catch {
    Write-Error "Unexpected error: $($_.Exception.Message)"
    Write-Host "Log file: $script:LogFile" -ForegroundColor Yellow
    exit $script:ErrorCodes.InstallationFailed
}
# ================================================================
# Platform Connection Verification System
# ================================================================

function Test-BridgeConnection {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$true)]
        [string]$PairCode,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId,
        
        [Parameter(Mandatory=$false)]
        [string]$BridgeExecutablePath,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30,
        
        [Parameter(Mandatory=$false)]
        [switch]$DetailedDiagnostics
    )
    
    Write-InstallationLog -Level Info -Message "Testing bridge connection to platform..."
    
    $connectionResult = @{
        Success = $false
        PlatformReachable = $false
        AuthenticationValid = $false
        ServiceResponding = $false
        NetworkConnectivity = $false
        FirewallBlocking = $false
        ErrorDetails = @()
        DiagnosticInfo = @{}
        TestResults = @{}
    }
    
    try {
        # Step 1: Test basic network connectivity
        Write-InstallationLog -Level Debug -Message "Testing network connectivity..."
        $networkTest = Test-NetworkConnectivity -PlatformEndpoint $PlatformEndpoint -TimeoutSeconds $TimeoutSeconds
        $connectionResult.NetworkConnectivity = $networkTest.Success
        $connectionResult.TestResults.NetworkConnectivity = $networkTest
        
        if (-not $networkTest.Success) {
            $connectionResult.ErrorDetails += "Network connectivity failed: $($networkTest.ErrorMessage)"
            Write-InstallationLog -Level Error -Message "Network connectivity test failed: $($networkTest.ErrorMessage)"
        }
        else {
            Write-InstallationLog -Level Success -Message "Network connectivity test passed"
        }
        
        # Step 2: Test platform endpoint reachability
        Write-InstallationLog -Level Debug -Message "Testing platform endpoint reachability..."
        $platformTest = Test-PlatformEndpoint -PlatformEndpoint $PlatformEndpoint -TimeoutSeconds $TimeoutSeconds
        $connectionResult.PlatformReachable = $platformTest.Success
        $connectionResult.TestResults.PlatformEndpoint = $platformTest
        
        if (-not $platformTest.Success) {
            $connectionResult.ErrorDetails += "Platform endpoint unreachable: $($platformTest.ErrorMessage)"
            Write-InstallationLog -Level Error -Message "Platform endpoint test failed: $($platformTest.ErrorMessage)"
        }
        else {
            Write-InstallationLog -Level Success -Message "Platform endpoint is reachable"
        }
        
        # Step 3: Test authentication with platform
        Write-InstallationLog -Level Debug -Message "Testing platform authentication..."
        $authTest = Test-PlatformAuthentication -PlatformEndpoint $PlatformEndpoint -PairCode $PairCode -GymId $GymId -TimeoutSeconds $TimeoutSeconds
        $connectionResult.AuthenticationValid = $authTest.Success
        $connectionResult.TestResults.Authentication = $authTest
        
        if (-not $authTest.Success) {
            $connectionResult.ErrorDetails += "Authentication failed: $($authTest.ErrorMessage)"
            Write-InstallationLog -Level Error -Message "Platform authentication test failed: $($authTest.ErrorMessage)"
        }
        else {
            Write-InstallationLog -Level Success -Message "Platform authentication successful"
        }
        
        # Step 4: Test bridge service if executable is available
        if ($BridgeExecutablePath -and (Test-Path $BridgeExecutablePath)) {
            Write-InstallationLog -Level Debug -Message "Testing bridge service functionality..."
            $serviceTest = Test-BridgeService -BridgeExecutablePath $BridgeExecutablePath -TimeoutSeconds $TimeoutSeconds
            $connectionResult.ServiceResponding = $serviceTest.Success
            $connectionResult.TestResults.BridgeService = $serviceTest
            
            if (-not $serviceTest.Success) {
                $connectionResult.ErrorDetails += "Bridge service test failed: $($serviceTest.ErrorMessage)"
                Write-InstallationLog -Level Warning -Message "Bridge service test failed: $($serviceTest.ErrorMessage)"
            }
            else {
                Write-InstallationLog -Level Success -Message "Bridge service test passed"
            }
        }
        
        # Step 5: Firewall detection
        Write-InstallationLog -Level Debug -Message "Checking for firewall blocking..."
        $firewallTest = Test-FirewallBlocking -PlatformEndpoint $PlatformEndpoint
        $connectionResult.FirewallBlocking = $firewallTest.IsBlocking
        $connectionResult.TestResults.Firewall = $firewallTest
        
        if ($firewallTest.IsBlocking) {
            $connectionResult.ErrorDetails += "Firewall may be blocking connection: $($firewallTest.Details)"
            Write-InstallationLog -Level Warning -Message "Firewall blocking detected: $($firewallTest.Details)"
        }
        else {
            Write-InstallationLog -Level Success -Message "No firewall blocking detected"
        }
        
        # Step 6: Detailed diagnostics if requested
        if ($DetailedDiagnostics) {
            Write-InstallationLog -Level Debug -Message "Running detailed connection diagnostics..."
            $diagnostics = Get-ConnectionDiagnostics -PlatformEndpoint $PlatformEndpoint -PairCode $PairCode -GymId $GymId
            $connectionResult.DiagnosticInfo = $diagnostics
        }
        
        # Determine overall success
        $connectionResult.Success = $connectionResult.NetworkConnectivity -and 
                                   $connectionResult.PlatformReachable -and 
                                   $connectionResult.AuthenticationValid -and
                                   (-not $connectionResult.FirewallBlocking)
        
        # Report connection status back to platform
        Send-ConnectionStatusToPlatform -ConnectionResult $connectionResult -PlatformEndpoint $PlatformEndpoint -GymId $GymId
        
        if ($connectionResult.Success) {
            Write-InstallationLog -Level Success -Message "Bridge connection test completed successfully"
        }
        else {
            Write-InstallationLog -Level Error -Message "Bridge connection test failed. See error details for troubleshooting."
        }
        
        return $connectionResult
    }
    catch {
        $connectionResult.ErrorDetails += "Connection test exception: $($_.Exception.Message)"
        Write-InstallationLog -Level Error -Message "Connection test failed with exception: $($_.Exception.Message)"
        return $connectionResult
    }
}

function Test-NetworkConnectivity {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30
    )
    
    $result = @{
        Success = $false
        ErrorMessage = ""
        ResponseTime = 0
        DNSResolution = $false
        TCPConnection = $false
        HTTPSConnection = $false
        Details = @{}
    }
    
    try {
        # Parse the platform endpoint to get hostname and port
        $uri = [System.Uri]::new($PlatformEndpoint)
        $hostname = $uri.Host
        $port = if ($uri.Port -ne -1) { $uri.Port } else { if ($uri.Scheme -eq "https") { 443 } else { 80 } }
        
        Write-InstallationLog -Level Debug -Message "Testing connectivity to $hostname`:$port"
        
        # Test 1: DNS Resolution
        try {
            $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            $dnsResult = [System.Net.Dns]::GetHostAddresses($hostname)
            $stopwatch.Stop()
            
            if ($dnsResult -and $dnsResult.Count -gt 0) {
                $result.DNSResolution = $true
                $result.Details.DNSAddresses = $dnsResult | ForEach-Object { $_.ToString() }
                $result.Details.DNSResponseTime = $stopwatch.ElapsedMilliseconds
                Write-InstallationLog -Level Debug -Message "DNS resolution successful: $($result.Details.DNSAddresses -join ', ')"
            }
            else {
                $result.ErrorMessage = "DNS resolution failed - no addresses returned"
                return $result
            }
        }
        catch {
            $result.ErrorMessage = "DNS resolution failed: $($_.Exception.Message)"
            return $result
        }
        
        # Test 2: TCP Connection
        try {
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            
            $connectTask = $tcpClient.ConnectAsync($hostname, $port)
            $completed = $connectTask.Wait($TimeoutSeconds * 1000)
            $stopwatch.Stop()
            
            if ($completed -and $tcpClient.Connected) {
                $result.TCPConnection = $true
                $result.Details.TCPResponseTime = $stopwatch.ElapsedMilliseconds
                Write-InstallationLog -Level Debug -Message "TCP connection successful ($($stopwatch.ElapsedMilliseconds)ms)"
                $tcpClient.Close()
            }
            else {
                $result.ErrorMessage = "TCP connection failed or timed out"
                return $result
            }
        }
        catch {
            $result.ErrorMessage = "TCP connection failed: $($_.Exception.Message)"
            return $result
        }
        finally {
            if ($tcpClient) {
                $tcpClient.Dispose()
            }
        }
        
        # Test 3: HTTPS Connection (if applicable)
        if ($uri.Scheme -eq "https") {
            try {
                $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
                $request = [System.Net.WebRequest]::Create($PlatformEndpoint)
                $request.Method = "HEAD"
                $request.Timeout = $TimeoutSeconds * 1000
                $request.UserAgent = "RepSet-Bridge-Installer/1.0"
                
                $response = $request.GetResponse()
                $stopwatch.Stop()
                
                if ($response.StatusCode -eq [System.Net.HttpStatusCode]::OK -or 
                    $response.StatusCode -eq [System.Net.HttpStatusCode]::NotFound) {
                    $result.HTTPSConnection = $true
                    $result.Details.HTTPSResponseTime = $stopwatch.ElapsedMilliseconds
                    $result.Details.HTTPSStatusCode = [int]$response.StatusCode
                    Write-InstallationLog -Level Debug -Message "HTTPS connection successful ($($stopwatch.ElapsedMilliseconds)ms, Status: $($response.StatusCode))"
                }
                
                $response.Close()
            }
            catch [System.Net.WebException] {
                # Some web exceptions are acceptable (like 404) as they indicate connectivity
                if ($_.Exception.Response) {
                    $result.HTTPSConnection = $true
                    $result.Details.HTTPSStatusCode = [int]$_.Exception.Response.StatusCode
                    Write-InstallationLog -Level Debug -Message "HTTPS connection successful with status: $($_.Exception.Response.StatusCode)"
                }
                else {
                    $result.ErrorMessage = "HTTPS connection failed: $($_.Exception.Message)"
                    return $result
                }
            }
            catch {
                $result.ErrorMessage = "HTTPS connection failed: $($_.Exception.Message)"
                return $result
            }
        }
        
        # Calculate overall response time
        $result.ResponseTime = if ($result.Details.HTTPSResponseTime) { 
            $result.Details.HTTPSResponseTime 
        } elseif ($result.Details.TCPResponseTime) { 
            $result.Details.TCPResponseTime 
        } else { 
            $result.Details.DNSResponseTime 
        }
        
        $result.Success = $result.DNSResolution -and $result.TCPConnection -and 
                         ($uri.Scheme -ne "https" -or $result.HTTPSConnection)
        
        return $result
    }
    catch {
        $result.ErrorMessage = "Network connectivity test failed: $($_.Exception.Message)"
        return $result
    }
}

function Test-PlatformEndpoint {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30
    )
    
    $result = @{
        Success = $false
        ErrorMessage = ""
        StatusCode = 0
        ResponseTime = 0
        ServerHeaders = @{}
        Details = @{}
    }
    
    try {
        Write-InstallationLog -Level Debug -Message "Testing platform endpoint: $PlatformEndpoint"
        
        # Test platform health/status endpoint
        $healthEndpoint = "$PlatformEndpoint/api/health"
        
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        
        try {
            $response = Invoke-WebRequest -Uri $healthEndpoint -Method GET -TimeoutSec $TimeoutSeconds -UserAgent "RepSet-Bridge-Installer/1.0" -ErrorAction Stop
            $stopwatch.Stop()
            
            $result.Success = $true
            $result.StatusCode = $response.StatusCode
            $result.ResponseTime = $stopwatch.ElapsedMilliseconds
            $result.Details.ContentLength = $response.Content.Length
            
            # Extract useful server headers
            foreach ($header in $response.Headers.Keys) {
                if ($header -in @('Server', 'X-Powered-By', 'X-Frame-Options', 'Content-Type')) {
                    $result.ServerHeaders[$header] = $response.Headers[$header]
                }
            }
            
            Write-InstallationLog -Level Debug -Message "Platform endpoint responded successfully (Status: $($result.StatusCode), Time: $($result.ResponseTime)ms)"
        }
        catch [System.Net.WebException] {
            $stopwatch.Stop()
            
            if ($_.Exception.Response) {
                $result.StatusCode = [int]$_.Exception.Response.StatusCode
                $result.ResponseTime = $stopwatch.ElapsedMilliseconds
                
                # Some status codes indicate the endpoint is reachable
                if ($result.StatusCode -in @(401, 403, 404, 405, 500)) {
                    $result.Success = $true
                    Write-InstallationLog -Level Debug -Message "Platform endpoint reachable but returned status $($result.StatusCode)"
                }
                else {
                    $result.ErrorMessage = "Platform endpoint returned status $($result.StatusCode): $($_.Exception.Message)"
                }
            }
            else {
                $result.ErrorMessage = "Platform endpoint unreachable: $($_.Exception.Message)"
            }
        }
        catch {
            $stopwatch.Stop()
            $result.ErrorMessage = "Platform endpoint test failed: $($_.Exception.Message)"
        }
        
        return $result
    }
    catch {
        $result.ErrorMessage = "Platform endpoint test exception: $($_.Exception.Message)"
        return $result
    }
}

function Test-PlatformAuthentication {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$true)]
        [string]$PairCode,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30
    )
    
    $result = @{
        Success = $false
        ErrorMessage = ""
        StatusCode = 0
        ResponseTime = 0
        AuthenticationDetails = @{}
    }
    
    try {
        Write-InstallationLog -Level Debug -Message "Testing platform authentication..."
        
        # Test authentication endpoint
        $authEndpoint = "$PlatformEndpoint/api/bridge/authenticate"
        
        $authData = @{
            pairCode = $PairCode
            gymId = $GymId
            deviceId = "installer-test-$(Get-Date -Format 'yyyyMMddHHmmss')"
            version = "installer-test"
        }
        
        $headers = @{
            'Content-Type' = 'application/json'
            'User-Agent' = 'RepSet-Bridge-Installer/1.0'
        }
        
        $body = $authData | ConvertTo-Json
        
        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
        
        try {
            $response = Invoke-RestMethod -Uri $authEndpoint -Method POST -Headers $headers -Body $body -TimeoutSec $TimeoutSeconds -ErrorAction Stop
            $stopwatch.Stop()
            
            $result.Success = $true
            $result.StatusCode = 200
            $result.ResponseTime = $stopwatch.ElapsedMilliseconds
            
            if ($response) {
                $result.AuthenticationDetails = $response
                Write-InstallationLog -Level Debug -Message "Authentication successful (Time: $($result.ResponseTime)ms)"
            }
        }
        catch [Microsoft.PowerShell.Commands.HttpResponseException] {
            $stopwatch.Stop()
            $result.StatusCode = $_.Exception.Response.StatusCode.Value__
            $result.ResponseTime = $stopwatch.ElapsedMilliseconds
            
            if ($result.StatusCode -eq 401) {
                $result.ErrorMessage = "Authentication failed - Invalid pair code or gym ID"
            }
            elseif ($result.StatusCode -eq 403) {
                $result.ErrorMessage = "Authentication failed - Access forbidden"
            }
            elseif ($result.StatusCode -eq 404) {
                $result.ErrorMessage = "Authentication endpoint not found - Platform may not support bridge authentication"
            }
            else {
                $result.ErrorMessage = "Authentication failed with status $($result.StatusCode): $($_.Exception.Message)"
            }
        }
        catch {
            $stopwatch.Stop()
            $result.ErrorMessage = "Authentication test failed: $($_.Exception.Message)"
        }
        
        return $result
    }
    catch {
        $result.ErrorMessage = "Authentication test exception: $($_.Exception.Message)"
        return $result
    }
}

function Test-BridgeService {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$BridgeExecutablePath,
        
        [Parameter(Mandatory=$false)]
        [int]$TimeoutSeconds = 30
    )
    
    $result = @{
        Success = $false
        ErrorMessage = ""
        ExecutableValid = $false
        VersionInfo = ""
        ConfigTest = $false
        Details = @{}
    }
    
    try {
        Write-InstallationLog -Level Debug -Message "Testing bridge service functionality..."
        
        # Test 1: Verify executable exists and is valid
        if (-not (Test-Path $BridgeExecutablePath)) {
            $result.ErrorMessage = "Bridge executable not found: $BridgeExecutablePath"
            return $result
        }
        
        $result.ExecutableValid = $true
        
        # Test 2: Get version information
        try {
            $versionOutput = & $BridgeExecutablePath --version 2>&1
            if ($LASTEXITCODE -eq 0) {
                $result.VersionInfo = $versionOutput -join " "
                Write-InstallationLog -Level Debug -Message "Bridge version: $($result.VersionInfo)"
            }
            else {
                Write-InstallationLog -Level Warning -Message "Bridge version check returned exit code: $LASTEXITCODE"
            }
        }
        catch {
            Write-InstallationLog -Level Warning -Message "Could not get bridge version: $($_.Exception.Message)"
        }
        
        # Test 3: Test configuration validation (if config exists)
        $configPath = Join-Path (Split-Path $BridgeExecutablePath -Parent) "config\config.yaml"
        if (Test-Path $configPath) {
            try {
                $configTestOutput = & $BridgeExecutablePath --config $configPath --validate-config 2>&1
                if ($LASTEXITCODE -eq 0) {
                    $result.ConfigTest = $true
                    Write-InstallationLog -Level Debug -Message "Bridge configuration validation passed"
                }
                else {
                    Write-InstallationLog -Level Warning -Message "Bridge configuration validation failed (exit code: $LASTEXITCODE)"
                }
            }
            catch {
                Write-InstallationLog -Level Warning -Message "Could not test bridge configuration: $($_.Exception.Message)"
            }
        }
        
        $result.Success = $result.ExecutableValid
        
        return $result
    }
    catch {
        $result.ErrorMessage = "Bridge service test exception: $($_.Exception.Message)"
        return $result
    }
}

function Test-FirewallBlocking {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint
    )
    
    $result = @{
        IsBlocking = $false
        Details = ""
        WindowsFirewallStatus = @{}
        NetworkProfiles = @{}
        FirewallRules = @()
    }
    
    try {
        Write-InstallationLog -Level Debug -Message "Checking for firewall blocking..."
        
        # Parse endpoint details
        $uri = [System.Uri]::new($PlatformEndpoint)
        $hostname = $uri.Host
        $port = if ($uri.Port -ne -1) { $uri.Port } else { if ($uri.Scheme -eq "https") { 443 } else { 80 } }
        
        # Check Windows Firewall status
        try {
            $firewallProfiles = Get-NetFirewallProfile -ErrorAction SilentlyContinue
            if ($firewallProfiles) {
                foreach ($profile in $firewallProfiles) {
                    $result.WindowsFirewallStatus[$profile.Name] = @{
                        Enabled = $profile.Enabled
                        DefaultInboundAction = $profile.DefaultInboundAction
                        DefaultOutboundAction = $profile.DefaultOutboundAction
                    }
                }
                
                # Check if any profile is blocking outbound connections
                $blockingProfiles = $firewallProfiles | Where-Object { $_.Enabled -and $_.DefaultOutboundAction -eq 'Block' }
                if ($blockingProfiles) {
                    $result.IsBlocking = $true
                    $result.Details = "Windows Firewall profiles blocking outbound: $($blockingProfiles.Name -join ', ')"
                }
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check Windows Firewall status: $($_.Exception.Message)"
        }
        
        # Check for specific firewall rules that might block the connection
        try {
            $outboundRules = Get-NetFirewallRule -Direction Outbound -Action Block -Enabled True -ErrorAction SilentlyContinue
            if ($outboundRules) {
                foreach ($rule in $outboundRules) {
                    $portFilter = Get-NetFirewallPortFilter -AssociatedNetFirewallRule $rule -ErrorAction SilentlyContinue
                    $addressFilter = Get-NetFirewallAddressFilter -AssociatedNetFirewallRule $rule -ErrorAction SilentlyContinue
                    
                    # Check if rule might affect our connection
                    $ruleAffectsConnection = $false
                    
                    if ($portFilter -and ($portFilter.RemotePort -eq $port -or $portFilter.RemotePort -eq 'Any')) {
                        $ruleAffectsConnection = $true
                    }
                    
                    if ($addressFilter -and ($addressFilter.RemoteAddress -eq $hostname -or $addressFilter.RemoteAddress -eq 'Any')) {
                        $ruleAffectsConnection = $true
                    }
                    
                    if ($ruleAffectsConnection) {
                        $result.FirewallRules += @{
                            Name = $rule.DisplayName
                            Description = $rule.Description
                            RemotePort = if ($portFilter) { $portFilter.RemotePort } else { "Any" }
                            RemoteAddress = if ($addressFilter) { $addressFilter.RemoteAddress } else { "Any" }
                        }
                        
                        if (-not $result.IsBlocking) {
                            $result.IsBlocking = $true
                            $result.Details = "Firewall rule '$($rule.DisplayName)' may be blocking connection"
                        }
                    }
                }
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not check firewall rules: $($_.Exception.Message)"
        }
        
        # Additional check: Test if we can make a simple connection
        if (-not $result.IsBlocking) {
            try {
                $tcpClient = New-Object System.Net.Sockets.TcpClient
                $connectTask = $tcpClient.ConnectAsync($hostname, $port)
                $connected = $connectTask.Wait(5000)  # 5 second timeout
                
                if (-not $connected -or -not $tcpClient.Connected) {
                    # Connection failed, but this doesn't necessarily mean firewall blocking
                    # Could be network issues, server down, etc.
                    Write-InstallationLog -Level Debug -Message "Connection test failed, but cause unclear"
                }
                
                $tcpClient.Close()
                $tcpClient.Dispose()
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Connection test failed: $($_.Exception.Message)"
            }
        }
        
        return $result
    }
    catch {
        Write-InstallationLog -Level Debug -Message "Firewall check failed: $($_.Exception.Message)"
        return $result
    }
}

function Get-ConnectionDiagnostics {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$true)]
        [string]$PairCode,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId
    )
    
    $diagnostics = @{
        SystemInfo = @{}
        NetworkInfo = @{}
        SecurityInfo = @{}
        PerformanceInfo = @{}
        TroubleshootingSteps = @()
    }
    
    try {
        Write-InstallationLog -Level Debug -Message "Gathering connection diagnostics..."
        
        # System Information
        $diagnostics.SystemInfo = @{
            OSVersion = [System.Environment]::OSVersion.VersionString
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            Architecture = [System.Environment]::ProcessorArchitecture
            MachineName = [System.Environment]::MachineName
            UserDomain = [System.Environment]::UserDomainName
            IsElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        }
        
        # Network Information
        try {
            $networkAdapters = Get-NetAdapter -Physical | Where-Object { $_.Status -eq 'Up' }
            $diagnostics.NetworkInfo.ActiveAdapters = $networkAdapters | ForEach-Object {
                @{
                    Name = $_.Name
                    InterfaceDescription = $_.InterfaceDescription
                    LinkSpeed = $_.LinkSpeed
                    MediaType = $_.MediaType
                }
            }
            
            $defaultGateway = Get-NetRoute -DestinationPrefix '0.0.0.0/0' | Select-Object -First 1
            if ($defaultGateway) {
                $diagnostics.NetworkInfo.DefaultGateway = $defaultGateway.NextHop
            }
            
            $dnsServers = Get-DnsClientServerAddress | Where-Object { $_.AddressFamily -eq 2 -and $_.ServerAddresses }
            $diagnostics.NetworkInfo.DNSServers = $dnsServers.ServerAddresses
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not gather network info: $($_.Exception.Message)"
        }
        
        # Security Information
        try {
            $diagnostics.SecurityInfo.ExecutionPolicy = Get-ExecutionPolicy
            $diagnostics.SecurityInfo.WindowsDefenderStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue | Select-Object AntivirusEnabled, RealTimeProtectionEnabled
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not gather security info: $($_.Exception.Message)"
        }
        
        # Performance Information
        try {
            $uri = [System.Uri]::new($PlatformEndpoint)
            $hostname = $uri.Host
            
            # Ping test
            $pingResult = Test-Connection -ComputerName $hostname -Count 3 -ErrorAction SilentlyContinue
            if ($pingResult) {
                $diagnostics.PerformanceInfo.PingResults = @{
                    AverageResponseTime = ($pingResult | Measure-Object -Property ResponseTime -Average).Average
                    PacketLoss = (3 - $pingResult.Count) / 3 * 100
                }
            }
            
            # Traceroute (simplified)
            try {
                $traceRoute = Test-NetConnection -ComputerName $hostname -TraceRoute -ErrorAction SilentlyContinue
                if ($traceRoute -and $traceRoute.TraceRoute) {
                    $diagnostics.PerformanceInfo.TraceRoute = $traceRoute.TraceRoute
                    $diagnostics.PerformanceInfo.HopCount = $traceRoute.TraceRoute.Count
                }
            }
            catch {
                Write-InstallationLog -Level Debug -Message "Traceroute failed: $($_.Exception.Message)"
            }
        }
        catch {
            Write-InstallationLog -Level Debug -Message "Could not gather performance info: $($_.Exception.Message)"
        }
        
        # Generate troubleshooting steps based on findings
        $diagnostics.TroubleshootingSteps = Get-TroubleshootingSteps -Diagnostics $diagnostics -PlatformEndpoint $PlatformEndpoint
        
        return $diagnostics
    }
    catch {
        Write-InstallationLog -Level Warning -Message "Could not gather complete diagnostics: $($_.Exception.Message)"
        return $diagnostics
    }
}

function Get-TroubleshootingSteps {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Diagnostics,
        
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint
    )
    
    $steps = @()
    
    # Check for common issues and provide solutions
    
    # Network connectivity issues
    if ($Diagnostics.NetworkInfo.ActiveAdapters.Count -eq 0) {
        $steps += "No active network adapters found. Check network cable connections and adapter status."
    }
    
    if (-not $Diagnostics.NetworkInfo.DefaultGateway) {
        $steps += "No default gateway configured. Check network configuration and DHCP settings."
    }
    
    if (-not $Diagnostics.NetworkInfo.DNSServers -or $Diagnostics.NetworkInfo.DNSServers.Count -eq 0) {
        $steps += "No DNS servers configured. Check network settings and DNS configuration."
    }
    
    # Performance issues
    if ($Diagnostics.PerformanceInfo.PingResults -and $Diagnostics.PerformanceInfo.PingResults.AverageResponseTime -gt 1000) {
        $steps += "High network latency detected ($($Diagnostics.PerformanceInfo.PingResults.AverageResponseTime)ms). Check network connection quality."
    }
    
    if ($Diagnostics.PerformanceInfo.PingResults -and $Diagnostics.PerformanceInfo.PingResults.PacketLoss -gt 0) {
        $steps += "Packet loss detected ($($Diagnostics.PerformanceInfo.PingResults.PacketLoss)%). Check network stability."
    }
    
    # Security issues
    if ($Diagnostics.SecurityInfo.ExecutionPolicy -eq 'Restricted') {
        $steps += "PowerShell execution policy is Restricted. Run: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser"
    }
    
    if ($Diagnostics.SecurityInfo.WindowsDefenderStatus -and $Diagnostics.SecurityInfo.WindowsDefenderStatus.RealTimeProtectionEnabled) {
        $steps += "Windows Defender real-time protection is enabled. Consider adding RepSet Bridge to exclusions if connection issues persist."
    }
    
    # System issues
    if (-not $Diagnostics.SystemInfo.IsElevated) {
        $steps += "Not running as Administrator. Some network diagnostics and firewall checks may be limited."
    }
    
    # Generic troubleshooting steps
    $steps += "Verify the platform endpoint URL is correct: $PlatformEndpoint"
    $steps += "Check if corporate firewall or proxy is blocking outbound HTTPS connections"
    $steps += "Ensure Windows Firewall allows outbound connections for RepSet Bridge"
    $steps += "Try temporarily disabling antivirus software to test connectivity"
    $steps += "Contact your network administrator if issues persist"
    
    return $steps
}

function Send-ConnectionStatusToPlatform {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ConnectionResult,
        
        [Parameter(Mandatory=$true)]
        [string]$PlatformEndpoint,
        
        [Parameter(Mandatory=$true)]
        [string]$GymId
    )
    
    try {
        Write-InstallationLog -Level Debug -Message "Sending connection status to platform..."
        
        $statusData = @{
            installationId = $script:InstallationId
            gymId = $GymId
            timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.fffZ'
            connectionTest = @{
                success = $ConnectionResult.Success
                networkConnectivity = $ConnectionResult.NetworkConnectivity
                platformReachable = $ConnectionResult.PlatformReachable
                authenticationValid = $ConnectionResult.AuthenticationValid
                serviceResponding = $ConnectionResult.ServiceResponding
                firewallBlocking = $ConnectionResult.FirewallBlocking
                errorDetails = $ConnectionResult.ErrorDetails
            }
            testResults = $ConnectionResult.TestResults
            diagnosticInfo = $ConnectionResult.DiagnosticInfo
        }
        
        $platformUrl = "$PlatformEndpoint/api/installation/connection-status"
        $headers = @{
            'Content-Type' = 'application/json'
            'User-Agent' = 'RepSet-Bridge-Installer/1.0'
        }
        
        $json = $statusData | ConvertTo-Json -Depth 5
        
        # Send status update asynchronously
        Start-Job -ScriptBlock {
            param($Url, $Headers, $Data)
            try {
                Invoke-RestMethod -Uri $Url -Method Post -Headers $Headers -Body $Data -TimeoutSec 10 -ErrorAction SilentlyContinue
            }
            catch {
                # Silently ignore platform status update failures
            }
        } -ArgumentList $platformUrl, $headers, $json | Out-Null
        
        Write-InstallationLog -Level Debug -Message "Connection status sent to platform"
    }
    catch {
        Write-InstallationLog -Level Debug -Message "Could not send connection status to platform: $($_.Exception.Message)"
    }
}

function Write-ConnectionTroubleshootingGuide {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ConnectionResult
    )
    
    Write-InstallationLog -Level Info -Message ""
    Write-InstallationLog -Level Info -Message "=== CONNECTION TROUBLESHOOTING GUIDE ==="
    Write-InstallationLog -Level Info -Message ""
    
    if ($ConnectionResult.Success) {
        Write-InstallationLog -Level Success -Message "✓ All connection tests passed successfully!"
        Write-InstallationLog -Level Info -Message "The RepSet Bridge should be able to connect to the platform."
    }
    else {
        Write-InstallationLog -Level Error -Message "❌ Connection tests failed. Please review the issues below:"
        Write-InstallationLog -Level Info -Message ""
        
        # Network connectivity issues
        if (-not $ConnectionResult.NetworkConnectivity) {
            Write-InstallationLog -Level Error -Message "❌ Network Connectivity Failed"
            Write-InstallationLog -Level Info -Message "   • Check your internet connection"
            Write-InstallationLog -Level Info -Message "   • Verify network cables are connected"
            Write-InstallationLog -Level Info -Message "   • Check network adapter status in Device Manager"
            Write-InstallationLog -Level Info -Message ""
        }
        else {
            Write-InstallationLog -Level Success -Message "✓ Network Connectivity OK"
        }
        
        # Platform reachability issues
        if (-not $ConnectionResult.PlatformReachable) {
            Write-InstallationLog -Level Error -Message "❌ Platform Endpoint Unreachable"
            Write-InstallationLog -Level Info -Message "   • Verify the platform URL is correct"
            Write-InstallationLog -Level Info -Message "   • Check if corporate firewall is blocking access"
            Write-InstallationLog -Level Info -Message "   • Try accessing the platform in a web browser"
            Write-InstallationLog -Level Info -Message ""
        }
        else {
            Write-InstallationLog -Level Success -Message "✓ Platform Endpoint Reachable"
        }
        
        # Authentication issues
        if (-not $ConnectionResult.AuthenticationValid) {
            Write-InstallationLog -Level Error -Message "❌ Platform Authentication Failed"
            Write-InstallationLog -Level Info -Message "   • Verify the pair code is correct and not expired"
            Write-InstallationLog -Level Info -Message "   • Check that the gym ID matches your account"
            Write-InstallationLog -Level Info -Message "   • Generate a new installation command if needed"
            Write-InstallationLog -Level Info -Message ""
        }
        else {
            Write-InstallationLog -Level Success -Message "✓ Platform Authentication OK"
        }
        
        # Firewall issues
        if ($ConnectionResult.FirewallBlocking) {
            Write-InstallationLog -Level Warning -Message "⚠ Firewall May Be Blocking Connection"
            Write-InstallationLog -Level Info -Message "   • Check Windows Firewall settings"
            Write-InstallationLog -Level Info -Message "   • Add RepSet Bridge to firewall exceptions"
            Write-InstallationLog -Level Info -Message "   • Contact your IT administrator about firewall rules"
            Write-InstallationLog -Level Info -Message ""
        }
        else {
            Write-InstallationLog -Level Success -Message "✓ No Firewall Blocking Detected"
        }
        
        # Service issues
        if ($ConnectionResult.TestResults.ContainsKey('BridgeService') -and -not $ConnectionResult.ServiceResponding) {
            Write-InstallationLog -Level Warning -Message "⚠ Bridge Service Test Failed"
            Write-InstallationLog -Level Info -Message "   • The bridge executable may have issues"
            Write-InstallationLog -Level Info -Message "   • Check the installation log for errors"
            Write-InstallationLog -Level Info -Message "   • Try reinstalling the bridge"
            Write-InstallationLog -Level Info -Message ""
        }
        
        # Error details
        if ($ConnectionResult.ErrorDetails -and $ConnectionResult.ErrorDetails.Count -gt 0) {
            Write-InstallationLog -Level Info -Message "Detailed Error Information:"
            foreach ($error in $ConnectionResult.ErrorDetails) {
                Write-InstallationLog -Level Info -Message "   • $error"
            }
            Write-InstallationLog -Level Info -Message ""
        }
        
        # Troubleshooting steps
        if ($ConnectionResult.DiagnosticInfo -and $ConnectionResult.DiagnosticInfo.TroubleshootingSteps) {
            Write-InstallationLog -Level Info -Message "Recommended Troubleshooting Steps:"
            foreach ($step in $ConnectionResult.DiagnosticInfo.TroubleshootingSteps) {
                Write-InstallationLog -Level Info -Message "   $($ConnectionResult.DiagnosticInfo.TroubleshootingSteps.IndexOf($step) + 1). $step"
            }
            Write-InstallationLog -Level Info -Message ""
        }
    }
    
    Write-InstallationLog -Level Info -Message "For additional support, please provide this log file to RepSet support."
    Write-InstallationLog -Level Info -Message "Log file location: $script:LogFile"
    Write-InstallationLog -Level Info -Message ""
    Write-InstallationLog -Level Info -Message "=== END TROUBLESHOOTING GUIDE ==="
}

# ================================================================
# Main Execution Block
# ================================================================

# Execute the installation if this script is run directly
if ($MyInvocation.InvocationName -ne '.') {
    try {
        $exitCode = Install-RepSetBridge
        
        # Display final log summary
        $logSummary = Get-InstallationLogSummary
        Write-Host ""
        Write-Host "Installation Log Summary:" -ForegroundColor Cyan
        Write-Host "  Log File: $($logSummary.LogFile)" -ForegroundColor White
        Write-Host "  Log Size: $([math]::Round($logSummary.Size / 1KB, 2)) KB" -ForegroundColor White
        Write-Host "  Total Lines: $($logSummary.Lines)" -ForegroundColor White
        Write-Host "  Errors: $($logSummary.Errors)" -ForegroundColor $(if ($logSummary.Errors -gt 0) { 'Red' } else { 'Green' })
        Write-Host "  Warnings: $($logSummary.Warnings)" -ForegroundColor $(if ($logSummary.Warnings -gt 0) { 'Yellow' } else { 'Green' })
        
        # Clean up background jobs
        Get-Job | Where-Object { $_.Name -like "*RepSet*" -or $_.State -eq 'Completed' } | Remove-Job -Force -ErrorAction SilentlyContinue
        
        exit $exitCode
    }
    catch {
        Write-Host "Fatal error during installation: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "Please check the installation log for details: $script:LogFile" -ForegroundColor Yellow
        exit $script:ErrorCodes.InstallationFailed
    }
}